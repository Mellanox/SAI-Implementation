/*
Copyright 2018 Mellanox.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* libfx_base autogenerated by P4 Compiler v1.0 */
/* From bmtor on May 08, 2020 08:39AM */

/* gcc acl.c -g -std=gnu99 -Wall -lsxnet -lsxapi -lsxcomp -lsxlog -oacl*/
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <sys/errno.h>
#include <sys/fcntl.h>

/* Spectrum FX APIs */
#include <fx_base_api.h>
#include <fx_base_range_match.h>
#include <fx_base_bitmap.h>
#include <fx_base_action.h>
#include <fx_base_parser.h>

/* Autogenerated FX implementation */
#include <flextrum_types.h>

/* Mellanox SDK */
#include <sx/sdk/sx_api.h>
#include <sx/sdk/sx_api_acl.h>
#include <sx/sdk/sx_api_bridge.h>
#include <sx/sdk/sx_api_init.h>
#include <sx/sdk/sx_api_fdb.h>
#include <sx/sdk/sx_api_flex_acl.h>
#include <sx/sdk/sx_api_flow_counter.h>
#include <sx/sdk/sx_api_host_ifc.h>
#include <sx/sdk/sx_api_port.h>
#include <sx/sdk/sx_api_router.h>
#include <sx/sdk/sx_api_span.h>
#include <sx/sdk/sx_api_tunnel.h>
#include <sx/sdk/sx_api_vlan.h>
#include <sx/sdk/sx_lib_flex_acl.h>
#include <sx/sdk/sx_lib_host_ifc.h>
#include <sx/sdk/sx_port.h>
#include <sx/sdk/sx_port_id.h>
#include <sx/sdk/sx_trap_id.h>

#include <arpa/inet.h>
#include <syslog.h>

#include <complib/sx_log.h>

/////////////////////////////
// defines
/////////////////////////////
typedef u_int8_t uint8_t;

const uint32_t ENDIAN_INT = 1;
#define is_bigendian() ( (*(char*)&ENDIAN_INT ) == 0 )

sx_status_t acl_keys_validate(sx_flex_acl_flex_rule_t  *rule);

// TODO - fix this per pipeline macro in the general template, as it depends
// upon the syntax used in the p4 compiler
#define CONTROL_IN_PORT_TABLE_NUM 0
#define CONTROL_IN_RIF_TABLE_NUM 2
#define CONTROL_OUT_RIF_TABLE_NUM 1
#define CONTROL_OUT_PORT_TABLE_NUM 0

#define MAX_LOG_PORTS 64
#define MAX_LOG_PORT_INDEX 64
#define MIN_LABEL_PORT_INDEX 1
#define MAX_LABEL_PORT_INDEX (MAX_LOG_PORTS + 1)

#define MAX_RIFS RM_API_ROUTER_RIFS_MAX

// #define SPECTRUM2_SPAN_SESSION_ID_MAX_EXTERNAL   7    /* available to user. Please note HW doesn't allow to edit sessions, hence to user we expose less number of sessions. */
#define SPAN_SESSION_INVALID 0xFF

#undef __MODULE__
#define __MODULE__ FXAPI_BASE
static sx_verbosity_level_t LOG_VAR_NAME(__MODULE__) = SX_VERBOSITY_LEVEL_NOTICE;

#define FX_LOG(L, FMT, ...)                                                         \
    do {                                                                            \
        SX_LOG(L, "[%s] %s:%i: " FMT, __FILE__, __func__,__LINE__, ## __VA_ARGS__); \
    } while (0)

typedef sx_port_log_id_t port_handle_type;
typedef sx_router_interface_t rif_handle_type;

typedef struct acl_table {
    fx_table_id_t     table_id;
    sx_acl_size_t           table_size;
    sx_acl_direction_t      pipe_line;
    sx_acl_region_id_t      region_id;
    sx_acl_id_t             acl_id;
    sx_acl_id_t             group_id;
    sx_acl_key_type_t       key_handle;
    sx_acl_key_t            *key_list;
    uint32_t                key_count; 
    sx_flow_counter_id_t*   rule_counters;
    fx_bitmap_t             valid_offsets;
    sx_acl_rule_offset_t    default_entry_offset;
    sx_acl_rule_offset_t    const_entry_offset;
    char                    table_name[MAX_TABLE_NAME_LEN];
    fx_range_table_t*       range_table; /* Used for Range match type and future extensions */
}acl_table;

typedef struct fx_custom_params {
    boolean_t is_cb;              /* true - use this custum byte set */
    uint32_t cb_offset;           /* extraction offset from start of header */
    uint32_t cb_size;             /* extraction size in bytes to extract */
    uint32_t field_offset;        /* offset of field from start of header */
    uint32_t field_size;          /* size in bytes of field */
    uint32_t cb_key_index_start;  /* starting index in the acl key list */
    uint32_t cb_key_list_size;    /* number of CB list entries */
    sx_acl_custom_bytes_set_attributes_t  attr;
}fx_custom_params;

typedef struct fx_span_session {
    sx_span_session_id_t session_id;
    sx_port_log_id_t ingress;
    sx_port_log_id_t egress;
}fx_span_session;

//fx_handle_t is just a pointer to fx_handle
typedef struct fx_handle {
    sx_api_handle_t      sdk_handle;
    sx_port_log_id_t     log_port_list[MAX_LABEL_PORT_INDEX];
    uint32_t             label_port_list[MAX_LABEL_PORT_INDEX];
    uint32_t             index_port_list[MAX_LOG_PORT_INDEX+1];
    uint32_t             port_mode[MAX_LABEL_PORT_INDEX];
    uint32_t             port_cnt;
    struct acl_table     acl_tables[3];
    uint8_t              num_sdk_actions_for_action_id[8];

    sx_acl_id_t          control_in_port_group_id;
    sx_acl_id_t          control_in_port_id_list[CONTROL_IN_PORT_TABLE_NUM];
    sx_acl_id_t          control_in_rif_group_id;
    sx_acl_id_t          control_in_rif_id_list[CONTROL_IN_RIF_TABLE_NUM];
    sx_acl_id_t          control_out_rif_group_id;
    sx_acl_id_t          control_out_rif_id_list[CONTROL_OUT_RIF_TABLE_NUM];
    sx_acl_id_t          control_out_port_group_id;
    sx_acl_id_t          control_out_port_id_list[CONTROL_OUT_PORT_TABLE_NUM];

    sx_acl_id_t*         pre_pipe_id_list[FX_PIPE_TYPE_MAX];           /* application supplied flex acl */
    uint32_t             pre_pipe_id_count[FX_PIPE_TYPE_MAX];
    sx_acl_id_t*         post_pipe_id_list[FX_PIPE_TYPE_MAX];          /* application supplied flex acl */
    uint32_t             post_pipe_id_count[FX_PIPE_TYPE_MAX];

    // Action state - tables that map logical ports to internal SDK resource IDs
    sx_acl_pbs_id_t      pbs_id_table[SX_ACL_PBS_ENTRY_TYPE_MAX+1][MAX_LABEL_PORT_INDEX];
    fx_span_session      span_session_table[MAX_LABEL_PORT_INDEX];

    int                  config_fd;
}fx_handle;

/* per table function implemntatons declerations */
typedef sx_status_t fx_table_x_entry_add (fx_handle_t handle,
        fx_action_id_t action_id,
        fx_key_list_t keys,
        fx_param_list_t params,
        sx_acl_rule_offset_t* offset_ptr);
// per table remove needed only for range tables
typedef sx_status_t fx_table_x_entry_remove (fx_handle_t handle,
        uint8_t offset);

// typedef sx_status_t (*fx_table_x_entry_remove)(fx_handle_t handle, uint32_t table_id ,sx_acl_rule_offset_t offset);

typedef sx_status_t fx_create_pipe_x(fx_handle_t handle,
        void *if_list,
        uint32_t if_list_cnt);

typedef sx_status_t fx_delete_pipe_x(fx_handle_t handle);

typedef sx_status_t fx_rebind_pipe_x(fx_handle_t handle,
        void *if_list,
        uint32_t if_list_cnt);

typedef sx_status_t fx_binding_update_pipe_x(fx_handle_t handle,
                                             void *iface,
                                             bool is_add);

typedef sx_status_t fx_table_x_default_entry_set(fx_handle_t handle,
        struct acl_table *table,
        fx_param_list_t params,
        int action_id);

typedef void fx_table_x_deinit_keys(fx_key_list_t keys[], size_t rule_cnt);
typedef void fx_table_x_init_keys(fx_key_list_t keys[], size_t rule_cnt);

/* Functions mapping */
fx_create_pipe_x create_pipe_control_in_port, create_pipe_control_in_rif,create_pipe_control_out_rif,create_pipe_control_out_port; // TODO - make python output.
fx_delete_pipe_x delete_pipe_control_in_port, delete_pipe_control_in_rif,delete_pipe_control_out_rif,delete_pipe_control_out_port; // TODO - make python output.
fx_rebind_pipe_x rebind_pipe_control_in_port, rebind_pipe_control_in_rif,rebind_pipe_control_out_rif,rebind_pipe_control_out_port; // TODO - make python output.
fx_binding_update_pipe_x binding_update_pipe_control_in_rif, binding_update_pipe_control_out_rif;
fx_create_pipe_x *fx_create_pipe_x_fn[4] = {create_pipe_control_in_port,create_pipe_control_in_rif,create_pipe_control_out_rif,create_pipe_control_out_port};
fx_delete_pipe_x *fx_delete_pipe_x_fn[4] = {delete_pipe_control_in_port,delete_pipe_control_in_rif,delete_pipe_control_out_rif,delete_pipe_control_out_port};
fx_rebind_pipe_x *fx_rebind_pipe_x_fn[4] = {rebind_pipe_control_in_port,rebind_pipe_control_in_rif,rebind_pipe_control_out_rif,rebind_pipe_control_out_port};
fx_binding_update_pipe_x *fx_binding_update_pipe_x_fn[4] = {NULL, binding_update_pipe_control_in_rif, binding_update_pipe_control_out_rif, NULL};
fx_table_x_entry_add  add_table_entry_control_in_rif_table_bitmap_classification, add_table_entry_control_in_rif_table_bitmap_router, add_table_entry_control_out_rif_table_meta_tunnel;
fx_table_x_entry_add * fx_table_x_entry_add_fn[3] = {add_table_entry_control_in_rif_table_bitmap_classification, add_table_entry_control_in_rif_table_bitmap_router, add_table_entry_control_out_rif_table_meta_tunnel};
fx_table_x_default_entry_set  fx_control_in_rif_table_bitmap_classification_default_entry_set, fx_control_in_rif_table_bitmap_router_default_entry_set, fx_control_out_rif_table_meta_tunnel_default_entry_set;
fx_table_x_default_entry_set * fx_table_x_default_entry_set_fn[3] = {fx_control_in_rif_table_bitmap_classification_default_entry_set, fx_control_in_rif_table_bitmap_router_default_entry_set, fx_control_out_rif_table_meta_tunnel_default_entry_set};
fx_table_x_init_keys  fx_init_key_list_control_in_rif_table_bitmap_classification, fx_init_key_list_control_in_rif_table_bitmap_router, fx_init_key_list_control_out_rif_table_meta_tunnel;
fx_table_x_init_keys * fx_table_x_init_keys_fn[3] = {fx_init_key_list_control_in_rif_table_bitmap_classification, fx_init_key_list_control_in_rif_table_bitmap_router, fx_init_key_list_control_out_rif_table_meta_tunnel};
fx_table_x_deinit_keys  fx_deinit_key_list_control_in_rif_table_bitmap_classification, fx_deinit_key_list_control_in_rif_table_bitmap_router, fx_deinit_key_list_control_out_rif_table_meta_tunnel;
fx_table_x_deinit_keys * fx_table_x_deinit_keys_fn[3] = {fx_deinit_key_list_control_in_rif_table_bitmap_classification, fx_deinit_key_list_control_in_rif_table_bitmap_router, fx_deinit_key_list_control_out_rif_table_meta_tunnel};
/////////////////////////////
// General functions
/////////////////////////////
sx_status_t init_port_mapping(fx_handle_t handle);
sx_status_t fx_actions_init(fx_handle_t handle);
sx_status_t fx_actions_deinit(fx_handle_t handle);
sx_status_t fx_parser_init(fx_handle_t handle);
sx_status_t fx_parser_deinit(fx_handle_t handle);

///////////////////////////
// Logging 
// ////////////////////////
sx_status_t
fx_log_verbosity_level_set(fx_handle_t handle, const sx_verbosity_level_t verbosity_level)
{
    LOG_VAR_NAME(__MODULE__) = verbosity_level;
    return SX_STATUS_SUCCESS;
}

///////////////////////////
// Jinja2 funtions
//////////////////////////
sx_status_t fx_table_entry_const_set(fx_handle_t handle, struct acl_table *table);

//sx_status_t fx_device_init(fx_handle_t handle, char* pci_dev, int* fd)
//{
//    if(handle == NULL && fd == NULL) {
//        return SX_STATUS_INVALID_HANDLE;
//    }
//
//    char *filename;
//    if (pci_dev == NULL) {
//        filename = "/sys/bus/pci/devices/0000:06:00.0/resource0";
//    }
//    else {
//        filename = pci_dev;
//    }
//
//    if (handle != NULL && handle->config_fd != -1) {
//        FX_LOG(SX_LOG_NOTICE, "%s already opened on fd %d.\n", filename, handle->config_fd);
//        *fd = handle->config_fd;
//        return SX_STATUS_SUCCESS;
//    }
//
//    int filedesc = -1;
//    if((filedesc = open(filename, O_RDWR | O_SYNC)) == -1) {
//        FX_LOG(SX_LOG_ERROR, "FX device init failed: [%s]\n", filename);
//        return SX_STATUS_ERROR;
//    }
//    if (handle != NULL) {
//        handle->config_fd = filedesc;
//    }
//    if (fd != NULL) {
//        *fd = filedesc;
//    }
//    FX_LOG(SX_LOG_NOTICE, "%s opened.\n", filename);
//    return SX_STATUS_SUCCESS;
//}
//
//sx_status_t fx_device_deinit(fx_handle_t handle)
//{
//    if(handle == NULL) {
//        return SX_STATUS_INVALID_HANDLE;
//    }
//    close(handle->config_fd);
//    handle->config_fd = -1;
//    return SX_STATUS_SUCCESS;
//}

/* Open spectrum SDK */
sx_status_t
fx_init(fx_handle_t *handle, const sx_api_handle_t *sx_handle)
{
    sx_status_t rc;
    *handle = malloc(sizeof (fx_handle));
    if(*handle==NULL) {
        return SX_STATUS_NO_MEMORY;
    }

    memset(*handle, 0, sizeof (fx_handle));
    (*handle)->config_fd = -1;

    FX_LOG(SX_LOG_NOTICE, "Opening SDK...\n");
    if (!sx_handle) {
        rc = sx_api_open(NULL, &(*handle)->sdk_handle);
        if (rc) {
            FX_LOG(SX_LOG_ERROR, "SDK API sx_api_open failed: [%s]\n", SX_STATUS_MSG(rc));
            return rc;
        }
    } else {
        (*handle)->sdk_handle = *sx_handle;
    }
    rc = fx_actions_init(*handle);
    if (rc) {
      FX_LOG(SX_LOG_ERROR, "FX INIT actions failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
    }
    fx_parser_init(*handle);

    rc = init_port_mapping(*handle);

    for (unsigned int type = 0; type <= SX_ACL_PBS_ENTRY_TYPE_MAX; type++) {
        for (unsigned int port_id = MIN_LABEL_PORT_INDEX; port_id < MAX_LABEL_PORT_INDEX; port_id++) {
            (*handle)->pbs_id_table[type][port_id] = SX_ACL_PBS_ID_INVALID;
        }
    }
    for (unsigned int port_id = MIN_LABEL_PORT_INDEX; port_id < MAX_LABEL_PORT_INDEX; port_id++) {
        (*handle)->span_session_table[port_id].session_id = SPAN_SESSION_INVALID;
        (*handle)->span_session_table[port_id].ingress = 0;
        (*handle)->span_session_table[port_id].egress = 0;
    }

    return rc;
}
/* Close spectrum SDK */
sx_status_t fx_deinit(fx_handle_t handle) {
    FX_LOG(SX_LOG_NOTICE, "Closing SDK...\n");
    fx_parser_deinit(handle);
    sx_status_t rc = fx_actions_deinit(handle);
    if (rc) {
      FX_LOG(SX_LOG_ERROR, "FX DEINIT actions failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    //rc = sx_api_close(&handle->sdk_handle);
    if (rc) {
       FX_LOG(SX_LOG_ERROR, "SDK API sx_api_close failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    memset(handle, 0, sizeof(fx_handle));
    handle->config_fd = -1;
    free(handle);
    return rc;
}

sx_status_t fx_sdk_handle_get(fx_handle_t handle, sx_api_handle_t *sdk_handle) {
    sx_status_t rc;
    if (handle != NULL && sdk_handle != NULL && handle->sdk_handle != SX_API_INVALID_HANDLE) {
        *sdk_handle = handle->sdk_handle;
        rc = SX_STATUS_SUCCESS;
    }
    else {
        rc = SX_STATUS_PARAM_ERROR;
    }
    return rc;
}

/* Create key handle */
sx_status_t 
create_acl_p4_key(fx_handle_t handle, struct acl_table * acl_table, struct fx_custom_params *custom)
{
    sx_status_t rc;
    if (custom && custom->is_cb) {
        /* P4C statically decides if the ACL key needs custom bytes */
        rc = sx_api_acl_custom_bytes_set(handle->sdk_handle,SX_ACCESS_CMD_CREATE,
                                                &custom->attr,
                                                &acl_table->key_list[custom->cb_key_index_start],
                                                &custom->cb_key_list_size);
        if (rc) {
            FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_custom_bytes_set failed: [%s]\n", SX_STATUS_MSG(rc));
            for (uint32_t i=custom->cb_key_index_start; i < custom->cb_key_index_start + custom->cb_key_list_size; i++) {
                FX_LOG(SX_LOG_ERROR, "%d, ", acl_table->key_list[i]);
            }
            return rc;
        }
    }

    rc = sx_api_acl_flex_key_set(
            handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_table->key_list,
            acl_table->key_count,
            &acl_table->key_handle);
    if (rc) {
        // TODO - syslog from SDK is SX_LOG_ERR("Failed calculating key blocks.\n") if
        // the acl key size is too large. This is hard to debug, need a compiler semantic check.
        if (acl_table->key_handle == 0) {
            FX_LOG(SX_LOG_ERROR, "Failed to set %i %s keys (hw limit exceeded)\n",
                    acl_table->key_count, acl_table->table_name);
        }
        FX_LOG(SX_LOG_DEBUG, "%s: sx_api_acl_flex_key_set: %s", rc ? "FAILURE" : "Success", acl_table->table_name);
        FX_LOG(SX_LOG_DEBUG, "handle 0x%x, %d keys: ", acl_table->key_handle, acl_table->key_count);
        FX_LOG(SX_LOG_DEBUG, "key_list = ");
        for (uint32_t i=0; i < acl_table->key_count; i++) {
            FX_LOG(SX_LOG_DEBUG,"%d, ", acl_table->key_list[i]);
        }
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_flex_key_set failed: [%s]\n", SX_STATUS_MSG(rc));
    }

    return rc;
}

/* Create ACL region */
sx_status_t create_acl_table(fx_handle_t handle,struct acl_table * acl_table)
{
    sx_status_t rc = sx_api_acl_region_set(handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_table->key_handle,
            SX_ACL_ACTION_TYPE_BASIC,
            acl_table->table_size,
            &acl_table->region_id);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_region_set failed: [%s]\n", SX_STATUS_MSG(rc));
        return(rc);
    }
    else {
        FX_LOG(SX_LOG_INFO, "sx_api_acl_region_set to id %#x\n", acl_table->region_id);
    }

    sx_acl_type_t acl_type = SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC;
    sx_acl_region_group_t acl_region_group = {
            .acl_type = acl_type,
            .regions = {
                    .acl_packet_agnostic = {
                            .region = acl_table->region_id,
                    }
            }
    };

    rc = sx_api_acl_set(handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_type,
            acl_table->pipe_line,//SX_ACL_DIRECTION_INGRESS,
            &acl_region_group,
            &acl_table->acl_id);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "Failed to create acl: [%s]\n", SX_STATUS_MSG(rc));
        return rc;
    }
    // TODO remove counters after verification
    acl_table->rule_counters = (sx_flow_counter_id_t*) malloc(sizeof(sx_flow_counter_id_t)*acl_table->table_size);

    alloc_bitmap(&acl_table->valid_offsets, acl_table->table_size);

    acl_table->default_entry_offset = acl_table->table_size - 1;
    acl_table->const_entry_offset = 0;
    return SX_STATUS_SUCCESS;
}

/* Create and set ACL Group */
sx_status_t assign_tables_to_group(fx_handle_t handle,sx_acl_direction_t direction, sx_acl_id_t* pipe_id_list, uint32_t pipe_table_num , sx_acl_id_t* pipe_group_id){
  sx_status_t rc = sx_api_acl_group_set(handle->sdk_handle,
                                        SX_ACCESS_CMD_CREATE,
                                        direction,
                                        pipe_id_list, // ignored upon create
                                        0,  // ignored upon create
                                        pipe_group_id);
  if (rc != SX_STATUS_SUCCESS) {
      FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_group_set failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  FX_LOG(SX_LOG_INFO, "Created pipe Group Id: %#x \n", *pipe_group_id);
  rc = sx_api_acl_group_set(handle->sdk_handle,
                                   SX_ACCESS_CMD_SET,
                                   direction,
                                   pipe_id_list,
                                   pipe_table_num,
                                   pipe_group_id);
  if (rc != SX_STATUS_SUCCESS) {
      FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_group_set failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  FX_LOG(SX_LOG_INFO, "SDK API: pipe tables added to pipe Group Id: %#x \n", *pipe_group_id);
  return SX_STATUS_SUCCESS;
}
// ----------------- port/ rif bindings -----------------------------

sx_status_t
fx_get_bindable_port_list(fx_handle_t handle, sx_port_log_id_t *if_list, uint32_t *if_list_cnt)
{
  sx_status_t rc;
  if (*if_list_cnt == 0) {
    rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, NULL, if_list_cnt);
    if (rc)
    {
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_port_device_get failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    return rc;
  }

  *if_list_cnt = 0;
  sx_port_attributes_t port_list[PORT_NUM];
  uint32_t num_of_ports = PORT_NUM;
  rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, port_list, &num_of_ports);
  if (rc)
  {
      FX_LOG(SX_LOG_ERROR, "SDK API sx_api_port_device_get failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  for (uint32_t i = 0; i < num_of_ports; i++)
  {
    if (port_list[i].port_mode == SX_PORT_MODE_EXTERNAL)
    {
      if_list[*if_list_cnt] = port_list[i].log_port;
      (*if_list_cnt)++;
    }
  }
  FX_LOG(SX_LOG_DEBUG, "Bindable ports:\n");
  for (uint32_t i = 0; i < *(if_list_cnt); i++)
  {
    FX_LOG(SX_LOG_INFO, " 0x%x\n", if_list[i]);
  }
  FX_LOG(SX_LOG_INFO, ".\nfx_get_port_if_list success, number of exernal interfaces: %d\n", *if_list_cnt);
  return SX_STATUS_SUCCESS;
}

sx_status_t fx_get_bindable_rif_list(fx_handle_t handle, sx_router_interface_t *if_list, uint32_t *if_list_cnt)
{
  bool print_rifs = (*if_list_cnt != 0);
  sx_status_t rc = sx_api_router_interface_iter_get(handle->sdk_handle, SX_ACCESS_CMD_GET, 0, 0, 0, if_list_cnt);
  if (rc != SX_STATUS_SUCCESS)
  {
      FX_LOG(SX_LOG_ERROR, "SDK API sx_api_router_interface_iter_get failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  rc = sx_api_router_interface_iter_get(handle->sdk_handle, SX_ACCESS_CMD_GET_FIRST, 0, 0, if_list, if_list_cnt);
  if (rc != SX_STATUS_SUCCESS)
  {
      FX_LOG(SX_LOG_ERROR, "SDK API sx_api_router_interface_iter_get failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  if (*if_list_cnt == 0)
  {
      FX_LOG(SX_LOG_WARNING, "No RIF configured in switch.\n");
      return SX_STATUS_SUCCESS;
  }
  if (print_rifs) {
    FX_LOG(SX_LOG_INFO, "Bindable rifs:\n");
    for (uint32_t i = 0; i < *(if_list_cnt); i++)
    {
      FX_LOG(SX_LOG_INFO, " 0x%x\n", if_list[i]);
    }
  }
  FX_LOG(SX_LOG_INFO,".\nfx_get_rif_if_list success, number of rifs: %d\n", *if_list_cnt);
  return SX_STATUS_SUCCESS;
}

//binding: 
// port:  const sx_port_log_id_t log_port - uint32_t
// rif : sx_rif_id_t rif_id uint32_t

// bind+unbind selector
sx_status_t
port_bind(fx_handle_t handle, const sx_acl_id_t group_id,boolean_t bind, sx_port_log_id_t *if_list, uint32_t if_list_cnt)
{
  if ((if_list == NULL && if_list_cnt != 0) || handle == NULL) return SX_STATUS_PARAM_ERROR;
  sx_status_t worst_rc = SX_STATUS_SUCCESS;
  sx_access_cmd_t bind_cmd = bind ? SX_ACCESS_CMD_BIND : SX_ACCESS_CMD_UNBIND;
  FX_LOG(SX_LOG_INFO,"%s P4 flex pipe to port ids: ", bind ? "Binding" : "Unbinding");
  char buffer[256];
  int c = snprintf(buffer, sizeof(buffer), "%s", "PORT-IDs:");
  for(uint32_t i=0;i<if_list_cnt;i++) {
    sx_status_t rc = sx_api_acl_port_bind_set(handle->sdk_handle,
                                            bind_cmd,
                                            if_list[i],
                                            group_id);
    if (rc != SX_STATUS_SUCCESS) {
      if (c<sizeof(buffer)) {
          c += snprintf(buffer+c, sizeof(buffer)-c, "%x,", if_list[i]);
      }
      if (rc > worst_rc) worst_rc = rc;
    }
  }
  if (worst_rc != SX_STATUS_SUCCESS) {
    FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_port_bind_set failed: [%s]\n", SX_STATUS_MSG(worst_rc));
  }
  else {
      if (c<sizeof(buffer)) {
          c += snprintf(buffer+c, sizeof(buffer)-c, " bound %i port successfully.",if_list_cnt);
      }
  }
  if (c<sizeof(buffer)) {
     c += snprintf(buffer+c, sizeof(buffer)-c, "%d,", '\0');
  }
  FX_LOG(SX_LOG_INFO, "%s\n",buffer);
  return worst_rc;
}

sx_status_t 
rif_bind(fx_handle_t handle, const sx_acl_id_t group_id,boolean_t bind, sx_router_interface_t *if_list, uint32_t if_list_cnt){
  if ((if_list == NULL && if_list_cnt != 0) || handle == NULL) return SX_STATUS_PARAM_ERROR;
  sx_status_t worst_rc = SX_STATUS_SUCCESS;
  sx_status_t rc;
  sx_access_cmd_t bind_cmd = bind ? SX_ACCESS_CMD_BIND : SX_ACCESS_CMD_UNBIND;
  FX_LOG(SX_LOG_INFO, "%s P4 flex pipe to rif ids: ", bind ? "Binding" : "Unbinding");
  char buffer[512];
  int c = snprintf(buffer, sizeof(buffer), "%s", "RIF-IDs:");
  for(uint32_t i=0;i<if_list_cnt;i++) {
    if (c<sizeof(buffer)) {
        c += snprintf(buffer+c, sizeof(buffer)-c, "%i,", if_list[i]);
    }
    rc = sx_api_acl_rif_bind_set (handle->sdk_handle,
                                  bind_cmd,
                                  if_list[i],
                                  group_id 
    );
    if (rc != SX_STATUS_SUCCESS) {
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_rif_bind_set failed: [%s]\n", SX_STATUS_MSG(rc));
        if (rc > worst_rc) worst_rc = rc;
    }
  }
  if (c<sizeof(buffer)) {
      c += snprintf(buffer+c, sizeof(buffer)-c, "%d,", '\0');
  }
  FX_LOG(SX_LOG_INFO, "%s\n",buffer);
  return worst_rc;
}

//------------------- ACL handling ----------------------------

sx_status_t
delete_acl_group(fx_handle_t handle,sx_acl_direction_t direction, sx_acl_id_t* pipe_group_id){
    sx_status_t rc = sx_api_acl_group_set(handle->sdk_handle,
                                     SX_ACCESS_CMD_DESTROY,
                                     direction,
                                     NULL, // ignored
                                     0, // ignored
                                     pipe_group_id);
    if (rc != SX_STATUS_SUCCESS) {
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_group_delete failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    else {
        FX_LOG(SX_LOG_INFO, "SDK API: group destroyed \n");
    }
    return rc;
}

int delete_acl(fx_handle_t handle,struct acl_table *acl_table)
{
  FX_LOG(SX_LOG_INFO, "Delete P4 table\n");
  sx_status_t           rc1 = SX_STATUS_SUCCESS;
  sx_status_t           rc2 = SX_STATUS_SUCCESS;
  free_bitmap(acl_table->valid_offsets);
  acl_table->valid_offsets = 0;
  free(acl_table->rule_counters);
  acl_table->rule_counters = 0;
  sx_acl_region_group_t acl_region_group = {
              .acl_type = SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC,
              .regions = {
                  .acl_packet_agnostic = {
                      .region = acl_table->region_id,
                  }
              }
          };
  rc1=sx_api_acl_set(handle->sdk_handle,
              SX_ACCESS_CMD_DESTROY,
                  SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC,
                  SX_ACL_DIRECTION_INGRESS,
                  &acl_region_group,
                  &acl_table->acl_id);
  if(rc1) {
    FX_LOG(SX_LOG_ERROR, "%s: failed to delete P4 Table: %s \n",SX_STATUS_MSG(rc1), acl_table->table_name);
  }

  rc2=sx_api_acl_region_set(handle->sdk_handle,
       SX_ACCESS_CMD_DESTROY,
            acl_table->key_handle,
            SX_ACL_ACTION_TYPE_BASIC,
            acl_table->table_size,
            &acl_table->region_id);
  if(rc2) {
    FX_LOG(SX_LOG_ERROR, "failed to delete table region: [%s]  \n",SX_STATUS_MSG(rc2));
   }
   return rc1 ? rc1 : rc2;
}

int remove_table_entry(fx_handle_t handle, struct acl_table *acl_table, sx_acl_rule_offset_t offset) {
    sx_status_t rc1 = SX_STATUS_SUCCESS;
    rc1 = sx_api_acl_flex_rules_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, acl_table->region_id, &offset, NULL, 1);
    if (rc1) {
        FX_LOG(SX_LOG_ERROR, "Failed to remove rule at offset %d: [%s]\n", offset, SX_STATUS_MSG(rc1));
    }
    sx_status_t rc2 = SX_STATUS_SUCCESS;
    if (0 != acl_table->rule_counters) {
        rc2 = sx_api_flow_counter_clear_set(handle->sdk_handle, acl_table->rule_counters[offset]);
    }
    if(rc2){
      FX_LOG(SX_LOG_ERROR, "failed to clear counter at offset %d, [%s]\n", offset, SX_STATUS_MSG(rc2));
    }
    if (0 != acl_table->valid_offsets) {
        reset_bitmap(acl_table->valid_offsets, offset);
    }
    return rc1 ? rc1 : rc2;
}

void delete_all_rules(fx_handle_t handle, struct acl_table *acl_table) {
    FX_LOG(SX_LOG_INFO, "Deleting all rules in table %s\n", acl_table->table_name);
    for (uint32_t i=0; i<acl_table->table_size; i++) {
        if (0 != acl_table->valid_offsets && get_bitmap(acl_table->valid_offsets, i) == 1) {
            remove_table_entry(handle, acl_table, i);
        }
    }
}

sx_status_t
delete_p4_key(fx_handle_t handle, struct acl_table *acl_table, struct fx_custom_params *custom)
{
  FX_LOG(SX_LOG_INFO, "Delete P4 key\n");
  sx_status_t rc1 = sx_api_acl_flex_key_set(handle->sdk_handle,
               SX_ACCESS_CMD_DELETE,
               acl_table->key_list,
               acl_table->key_count,
               &acl_table->key_handle);
  if(rc1) {
    FX_LOG(SX_LOG_ERROR, "Fail to Delete P4 Table key type. [%s]\n", SX_STATUS_MSG(rc1));
  }
  FX_LOG(SX_LOG_INFO, "Delete CB\n");
  sx_status_t rc2 = SX_STATUS_SUCCESS;
  if (custom && custom->is_cb) {
      /* P4C statically decides if the ACL key needs custom bytes */
      rc2 = sx_api_acl_custom_bytes_set(handle->sdk_handle,SX_ACCESS_CMD_DESTROY,
                                              &custom->attr,
                                              &acl_table->key_list[custom->cb_key_index_start],
                                              &custom->cb_key_list_size);
      if (rc2){
        FX_LOG(SX_LOG_ERROR, "ERROR: SDK API sx_api_acl_custom_bytes_set failed: [%s]\n", SX_STATUS_MSG(rc2));
      }
  }
  return rc1 ? rc1 : rc2;
}

/* Rule counters */
sx_status_t
alloc_rule_counters(fx_handle_t handle, struct acl_table *acl_table) {
  sx_status_t           rc = SX_STATUS_SUCCESS;
  FX_LOG(SX_LOG_INFO, "Allocating rule counters\n");
  for (uint32_t i=0;i<acl_table->table_size;i++)  {
    rc=sx_api_flow_counter_set(handle->sdk_handle,SX_ACCESS_CMD_CREATE,
      SX_FLOW_COUNTER_TYPE_PACKETS_AND_BYTES,&acl_table->rule_counters[i]);
    if(rc){
      FX_LOG(SX_LOG_ERROR, "Failed to allocate rule flow counter %d, [%s]\n", i,SX_STATUS_MSG(rc));
      return rc;
    }
  }
  return SX_STATUS_SUCCESS;
}

void delete_rule_counters(fx_handle_t handle, struct acl_table *acl_table) {
  FX_LOG(SX_LOG_INFO, "Delete table's rule counters\n");
  sx_status_t           rc = SX_STATUS_SUCCESS;
  FX_LOG(SX_LOG_INFO, "Deleting rule counters\n");
  for (uint32_t i=0;i<acl_table->table_size;i++)  {
    rc=sx_api_flow_counter_set(handle->sdk_handle,SX_ACCESS_CMD_DESTROY,
        SX_FLOW_COUNTER_TYPE_PACKETS_AND_BYTES,&acl_table->rule_counters[i]);
    if(rc) {
      FX_LOG(SX_LOG_ERROR, "Fail to  delete flow counter %d, [%s]\n", i, SX_STATUS_MSG(rc));
      return ;
    }
  }
}

/* map between table_id and fx_handle table index*/
sx_status_t get_table_index_from_id (fx_handle_t handle, const fx_table_id_t table_id, int *table_index){
  for (uint32_t i=0; i<3; i++){
    if(handle->acl_tables[i].table_id == table_id){
      *table_index = i;
      return SX_STATUS_SUCCESS;
    }
  }
  FX_LOG(SX_LOG_ERROR, "Flex Table not initialized, ID: %i\n", table_id);
  return SX_STATUS_UNSUPPORTED;
}

sx_status_t get_sdk_action_num_from_id (const fx_action_id_t action_id, int *sdk_actions_count){
  switch (action_id) {
    /* assign number of primitives per user defined action */
		/* ASSIGN_NUM_SDK_ACTIONS */
		case 16778278: /* CONTROL_IN_RIF_DROP_ID */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
		case 16786535: /* CONTROL_IN_RIF_SET_METADATA_ID */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
		case 16825799: /* CONTROL_IN_RIF_TO_NEXTHOP_ID */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
		case 16812468: /* CONTROL_OUT_RIF_TUNNEL_ENCAP_ID */
			*sdk_actions_count = 3;
			return SX_STATUS_SUCCESS;
		case 16800567: /* NOACTION_ID */
			*sdk_actions_count = 0;
			return SX_STATUS_SUCCESS;
		case 16841981: /* CONTROL_IN_RIF_TO_LOCAL_ID */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
      default:
        FX_LOG(SX_LOG_ERROR, "Requested action id is not in the action list: %i\n", action_id);
        return (SX_STATUS_PARAM_ERROR);
  }
}

/* These functions read/clear rule counters*/ 
// TODO : need to check if counter was asgined to rule if action has hit_counters()
// TODO : 
sx_status_t fx_table_rule_counters_print_all(fx_handle_t handle, fx_table_id_t table_id){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;

  struct acl_table *table = &handle->acl_tables[table_index];
  sx_status_t rc_final = SX_STATUS_SUCCESS;
  sx_flow_counter_set_t  counter;
  sx_acl_rule_offset_t offsets[table->table_size];
  uint32_t rules_cnt = 0;
  sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, offsets, NULL, &rules_cnt);
  FX_LOG(SX_LOG_INFO, "Table: %s. %d valid rules. rule counters: \n",table->table_name, rules_cnt);
  for (uint32_t i=0;i<table->table_size;i++){
    if (get_bitmap(table->valid_offsets, i) == 1) {
      rc=sx_api_flow_counter_get(handle->sdk_handle,SX_ACCESS_CMD_READ,table->rule_counters[i],&counter);
      if(rc){
          FX_LOG(SX_LOG_ERROR, "Rule %d counter is N/A \n", i);
        rc_final = rc;
      } else{
          FX_LOG(SX_LOG_INFO, "*rule %d; counter byte %" PRIu64 "; packets %" PRIu64 ";\n",i,counter.flow_counter_bytes,counter.flow_counter_packets);
      }
    }
  }
  return rc_final;
}



sx_status_t fx_table_rule_counters_clear_all(fx_handle_t handle, fx_table_id_t table_id){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  sx_status_t rc_final = SX_STATUS_SUCCESS;
  for (uint32_t i=0;i<table->table_size;i++){
      rc= sx_api_flow_counter_clear_set(handle->sdk_handle,table->rule_counters[i]);
      if(rc){
          FX_LOG(SX_LOG_ERROR, "Rule %d counter is N/A \n", i);
        rc_final = rc;
      }
    }
  FX_LOG(SX_LOG_INFO, "Counters cleared\n");
  return rc_final;
}


sx_status_t fx_table_rule_counter_read(fx_handle_t handle, fx_table_id_t table_id, sx_acl_rule_offset_t offset, uint64_t *bytes, uint64_t *packets){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;

  struct acl_table *table = &handle->acl_tables[table_index];
  sx_flow_counter_set_t  counter;
  if (get_bitmap(table->valid_offsets, offset) == 0) {
    FX_LOG(SX_LOG_ERROR, "Got invalid offset %d. table_id %d \n", offset, table_id);
    return SX_STATUS_PARAM_ERROR;
  }
  rc=sx_api_flow_counter_get(handle->sdk_handle,SX_ACCESS_CMD_READ,table->rule_counters[offset],&counter);
  if(rc){
    FX_LOG(SX_LOG_ERROR, "%d: rule counter is N/A \n", rc);
    return rc;
  } else{
    *bytes = counter.flow_counter_bytes;
    *packets = counter.flow_counter_packets;
  }
  return rc;
}

sx_status_t fx_table_rule_counter_clear(fx_handle_t handle, fx_table_id_t table_id, sx_acl_rule_offset_t offset){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  
  if (get_bitmap(table->valid_offsets, offset) == 0) {
    FX_LOG(SX_LOG_ERROR, "Got invalid offset %d. table_id %d \n", offset, table_id);
    return SX_STATUS_PARAM_ERROR;
  }
  rc= sx_api_flow_counter_clear_set(handle->sdk_handle,table->rule_counters[offset]);
  if(rc){
    return rc;
  }
  return rc;
}


sx_status_t create_p4_table(fx_handle_t handle, struct acl_table *table, struct fx_custom_params *custom) {
  FX_LOG(SX_LOG_INFO, "Create_p4_table. creating key\n");
  sx_status_t rc = create_acl_p4_key(handle, table, custom);
  if (rc) {return rc;}
  FX_LOG(SX_LOG_INFO, "Success, creating table:\n" );
  rc = create_acl_table(handle, table);
  if (rc) {return rc;}
  rc = alloc_rule_counters(handle, table);
  if (rc) {return rc;}
  return SX_STATUS_SUCCESS;
}

sx_status_t delete_p4_table(fx_handle_t handle, struct acl_table *table, struct fx_custom_params *custom) {
    FX_LOG(SX_LOG_INFO, "Delete_p4_table\n");
    delete_all_rules(handle, table);
    delete_rule_counters(handle, table);
    sx_status_t rc = delete_acl(handle, table);
    delete_p4_key(handle, table, custom);
    if (rc) {
      return rc;
    }
    return SX_STATUS_SUCCESS;
}

/* private function to get offsets */
void get_exact_offset_internal(struct acl_table *table, sx_acl_rule_offset_t *offset_ptr) {
    for (uint32_t i=0; i<table->table_size; i++) {
        if (get_bitmap(table->valid_offsets, i) == 0) {
          *offset_ptr = i;
          return;
        }
    }
    FX_LOG(SX_LOG_ERROR, "Exact match table %s is full\n", table->table_name);
    return;
}

/* private function to set the acl, for all table types */
int add_acl_rule_internal(fx_handle_t handle, sx_flex_acl_flex_rule_t* rule, sx_acl_rule_offset_t* rule_offset, struct acl_table *table) {
    sx_status_t rc = acl_keys_validate(rule);
    if (rc) {
        FX_LOG(SX_LOG_INFO,"ACL rule failed fx validation\n");
    }
    rc=sx_api_acl_flex_rules_set(handle->sdk_handle, SX_ACCESS_CMD_SET,  table->region_id, rule_offset, rule, 1);
  if(rc || rc == SX_STATUS_SUCCESS) {
      // DEBUG
    FX_LOG(SX_LOG_INFO,"ACL offset %d - %s\n", *rule_offset, rc == 0 ? "Success" : SX_STATUS_MSG(rc));
    FX_LOG(SX_LOG_INFO,"region id : %#x\tacl id : %#x\tgroup id : %#x\n", table->region_id, table->acl_id, table->group_id);
    for (uint32_t i=0; i < rule->key_desc_count; i++) {
        if (rule->key_desc_list_p[i].key_id >= FLEX_ACL_KEY_CUSTOM_BYTES_START) {
            FX_LOG(SX_LOG_INFO,"key #%d: custom byte key id : %d\t  value: %d\t  mask: %d\n",
                    i, rule->key_desc_list_p[i].key_id,
                    rule->key_desc_list_p[i].key.custom_byte,
                    rule->key_desc_list_p[i].mask.custom_byte);
        }
        else if (rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_DIP ||
                rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_SIP  ||
                rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_INNER_DIP ||
                rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_INNER_SIP) {
            FX_LOG(SX_LOG_INFO, "key #%d:\t IP ADDR id %d\t  value: %s\n",
                    i, rule->key_desc_list_p[i].key_id,
                    inet_ntoa(rule->key_desc_list_p[i].key.dip.addr.ipv4));
            FX_LOG(SX_LOG_INFO, "   \t  mask: %s\n",
                    inet_ntoa(rule->key_desc_list_p[i].mask.dip.addr.ipv4));
        }
        else {
            FX_LOG(SX_LOG_INFO, "key #%d:\t key id %d\t  value: 0x%x\t  mask: 0x%x\n",
                    i, rule->key_desc_list_p[i].key_id,
                    (uint32_t)rule->key_desc_list_p[i].key.src_port,
                    (uint32_t)rule->key_desc_list_p[i].mask.vni_key);
        }
    }
  }
  if(rc) {
    FX_LOG(SX_LOG_INFO, "ERROR %d: [%s] Failed to insert rule at offset %d\n", rc, SX_STATUS_MSG(rc),*rule_offset);
    return -1;
  } else {
      FX_LOG(SX_LOG_INFO, "FX_BASE - Inserted rule at offset %d\n", *rule_offset);
  }
  set_bitmap(table->valid_offsets, *rule_offset);
  return rc;
}

/*
 * Auto generate mapping of label port to logical port, used by the SDK APIs
 */
sx_status_t init_port_mapping(fx_handle_t handle) {
    // get all the ports
    handle->port_cnt = MAX_LOG_PORTS;
    sx_status_t rc = sx_api_port_swid_port_list_get(handle->sdk_handle,
            0,
            &handle->log_port_list[0],
            &handle->port_cnt);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "sx_api_port_swid_port_list_get: %s\n",SX_STATUS_MSG(rc));
        return rc;
    }
    sx_port_attributes_t* port_attrs = (sx_port_attributes_t*)malloc(sizeof(sx_port_attributes_t)*handle->port_cnt);
    uint32_t pattr = handle->port_cnt;
    rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, port_attrs, &pattr);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "Retrieving port mapping: %s\n",SX_STATUS_MSG(rc));
        free (port_attrs);
        return rc;
    }
    // There are 3 kinds of port IDs
    // 1. log_port   [0x10000..0x14000] - logical port, used in SDK APIs
    // 2. index      [0..31]            - similar to local port assigned by SDK, but internal to this app
    // 3. label_port [1..32]            - label port, as seen on the front panel
    // Assign label 0 to mean any port. Give it an index outside any physical port
    handle->label_port_list[0] = MAX_LOG_PORTS;
    handle->index_port_list[MAX_LOG_PORTS] = 0;
    handle->log_port_list[MAX_LOG_PORTS] = 0;
    for (unsigned int i = 0; i < handle->port_cnt; i++) {
        // Find the label of the port. This is the interface to the controller
        int label = 0;
        if (i < pattr) {
            label = port_attrs[i].port_mapping.module_port + 1;
            if (label <= MAX_LOG_PORTS) { // index zero based, label 1 based
                handle->label_port_list[label] = i;
                handle->index_port_list[i] = label;
                handle->port_mode[i] = port_attrs[i].port_mode;
                handle->log_port_list[i] = port_attrs[i].log_port;
            }
            else {
                FX_LOG(SX_LOG_ERROR, "Unable to map Logical port %i : %#010x,  label: %i\n",i, handle->log_port_list[i], label);
            }
        }
        else {
            FX_LOG(SX_LOG_INFO, "Logical port %i : %#010x,  label: UNKNOWN \n",i, handle->log_port_list[i]);
        }
    }
    free(port_attrs);
    return rc;
}

sx_status_t fx_logical_port_get(fx_handle_t handle, uint32_t label_port, sx_port_log_id_t* log_port) {
    sx_status_t rc = SX_STATUS_SUCCESS;
    if (handle == NULL) {
        FX_LOG(SX_LOG_ERROR, "fx_logical_port_get() %s\n","invalid handle parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    if (label_port > MAX_LOG_PORTS) {
        FX_LOG(SX_LOG_ERROR, "fx_logical_port_get() %s\n","invalid label port parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    if (log_port == NULL) {
        FX_LOG(SX_LOG_ERROR, "fx_logical_port_get() %s\n","invalid logical port parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    *log_port = handle->log_port_list[handle->label_port_list[label_port]];
    return rc;
}


/*  Thes functions create/destroy a control pipeline.*/
sx_status_t fx_pipe_create(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
  return(
    (*fx_create_pipe_x_fn[pipe_type])(handle, if_list, if_list_cnt));
}


sx_status_t fx_pipe_destroy(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
    /* TODO - move , if_list, if_list_cnt to fx_handle */
  (void)if_list;
  (void)if_list_cnt;
  return(
    (*fx_delete_pipe_x_fn[pipe_type])(handle));
}


sx_status_t fx_pipe_rebind(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
  return(
    (*fx_rebind_pipe_x_fn[pipe_type])(handle, if_list, if_list_cnt));
}

sx_status_t fx_pipe_binding_update(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *iface,
        bool is_add){
  return(
    (*fx_binding_update_pipe_x_fn[pipe_type])(handle, iface, is_add));
}

/* For external applications that create their own ACL tables, but then
 * want to bind in front of the ordered cascade of auto generated P4 tables
 */
sx_status_t fx_pipe_set_pre_acl_bind(fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        sx_acl_id_t *acl_list,
        uint32_t acl_list_cnt) {
    if (pipe_type >= FX_PIPE_TYPE_MIN && pipe_type < FX_PIPE_TYPE_MAX &&
            acl_list != 0 && acl_list_cnt != 0) {

        handle->pre_pipe_id_list[pipe_type] = acl_list;
        handle->pre_pipe_id_count[pipe_type] = acl_list_cnt;
        return SX_STATUS_SUCCESS;
    }
    else {
        return SX_STATUS_ERROR;
    }
}

/* For external applications that create their own ACL tables, but then
 * want to bind at the end of the ordered cascade of auto generated P4 tables
 */
sx_status_t fx_pipe_set_post_acl_bind(fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        sx_acl_id_t *acl_list,
        uint32_t acl_list_cnt) {
    if (pipe_type >= FX_PIPE_TYPE_MIN && pipe_type < FX_PIPE_TYPE_MAX &&
            acl_list != 0 && acl_list_cnt != 0) {

        handle->post_pipe_id_list[pipe_type] = acl_list;
        handle->post_pipe_id_count[pipe_type] = acl_list_cnt;
        return SX_STATUS_SUCCESS;
    }
    else {
        return SX_STATUS_ERROR;
    }
}


/*  These functions add/re
move a table entry
use function mapping to implement static api */

sx_status_t fx_table_entry_add(fx_handle_t handle, const fx_table_id_t table_id, const fx_action_id_t action_id, fx_key_list_t keys, fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  // TODO action enum to id 
  return((*fx_table_x_entry_add_fn[table_index])(handle, action_id, keys, params, offset_ptr) );
}

sx_status_t fx_table_entry_remove(fx_handle_t handle, const fx_table_id_t table_id, sx_acl_rule_offset_t offset){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  if (table->range_table==NULL){
    /* handle exact/ternery match tables */
    return(remove_table_entry( handle, table, offset));
  }
  else{
    /* handle range match tables */
    switch(table_id){
      default:
        FX_LOG(SX_LOG_ERROR, "ERROR: fx_table_entry_remove table_id: %d, table_id missmatch.\n",table_id);
        return(SX_STATUS_PARAM_ERROR);
    }
  }
}

/* find the rule that matches the keys, if caller does not know the offset */
sx_status_t fx_table_entry_offset_find(fx_handle_t handle, const fx_table_id_t table_id, fx_key_list_t keys,
        sx_acl_rule_offset_t* offset) {
    int table_index;
    sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
    if (rc) return rc;
    struct acl_table *table = &handle->acl_tables[table_index];
    sx_acl_rule_offset_t offsets[table->table_size];
    uint32_t rules_count = 0;
    for (uint32_t i=0; i<table->table_size; i++) {
        if (get_bitmap(table->valid_offsets, i) != 0) {
            offsets[rules_count] = i;
            rules_count++;
        }
    }
    sx_flex_acl_flex_rule_t* rules = (sx_flex_acl_flex_rule_t*) malloc(rules_count*sizeof(sx_flex_acl_flex_rule_t));
    for (uint32_t i=0; i<rules_count; i++) {
        sx_lib_flex_acl_rule_init(table->key_handle, 10, &rules[i]);
    }
    if (table->range_table==NULL){
        rc = sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, &offsets[0], rules, &rules_count);
        if (rc) {
            FX_LOG(SX_LOG_ERROR, "sx_api_acl_flex_rules_get() failed to find ACL rule: %i\n", rc);
        }
        else if (rules_count > 0) {
            rc = sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, &offsets[0], rules, &rules_count);
            rc = SX_STATUS_ENTRY_NOT_FOUND;
            bool found = false;
            for (uint32_t i=0; i<rules_count; i++) {
                // missing rule keys indicate don't care for ternary/lpm rules
                // they are identified by type instead of an index
                if (rules[i].key_desc_count <= keys.len) {
                    if (rules[i].key_desc_list_p != NULL) {
                        for (uint32_t j=0; j<rules[i].key_desc_count; j++) {
                            FX_LOG(SX_LOG_DEBUG, "Rule %i: key id %u\n",i, rules[i].key_desc_list_p[j].key_id);
                            const sx_acl_key_fields_t *key_fields = &rules[i].key_desc_list_p[j].key;
                            // fx_byte array has null values for ket index that mean don't care
                            int key_count = 0;
                            for (uint32_t y=0; y < keys.len; y++) {
                                if (keys.keys[y].key.data != NULL && key_count == j) {
                                    const fx_bytearray_t *key_data = &keys.keys[y].key;
                                    found = (0 == memcmp(&key_fields->buff, key_data->data, key_data->len));
                                    key_count++;
                                    break;
                                }
                            }
                        }
                        if (found) {
                            *offset = offsets[i];
                            rc = SX_STATUS_SUCCESS;
                            FX_LOG(SX_LOG_DEBUG, "Found Rule %i: offset %i",i, *offset);
                            break;
                        }
                    }
                }
                else {
                    FX_LOG(SX_LOG_ERROR, "Mismatch error in key count (%i > %i), table ID %i\n",
                            rules[i].key_desc_count, (int)keys.len, table_id);
                    for (uint32_t x=0; x < rules[i].key_desc_count; x++) {
                        if (rules[i].key_desc_list_p != NULL)
                            FX_LOG(SX_LOG_ERROR,"\t Key ID %i, value %#010x\n", rules[i].key_desc_list_p[x].key_id, rules[i].key_desc_list_p[x].key.mpls_label_id_1);
                    }
                    for (uint32_t y=0; y < keys.len; y++) {
                        if (keys.keys[y].key.data != NULL)
                            FX_LOG(SX_LOG_ERROR,"\t Key #%i, data %#010x\n", y, *((uint32_t*)keys.keys[y].key.data));
                    }
                    rc = SX_STATUS_PARAM_ERROR;
                }
            }
            if (!found) {
                FX_LOG(SX_LOG_ERROR, "Failed to find modify key out of %i flex rules\n", rules_count);
            }
        }
    }
    else {
        /* TODO - handle range match tables */
        rc = SX_STATUS_PARAM_ERROR;
        FX_LOG(SX_LOG_ERROR, "Modify range table not supported: %i\n", rc);
    }
    for (uint32_t i=0; i<rules_count; i++) {
        sx_lib_flex_acl_rule_deinit(&rules[i]);
    }
    free(rules);
    return rc;
}

sx_status_t fx_table_entry_default_set(fx_handle_t handle, const fx_table_id_t table_id, const fx_action_id_t action_id, fx_param_list_t params){
    int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  return( (*fx_table_x_default_entry_set_fn[table_index])(handle, table,params,action_id));
}


void fx_table_entry_print_all(fx_handle_t handle, char *buffer, size_t len) {
    const int num_tables = 3;
    int c = snprintf(buffer, len, "Rules for %i tables\n", 3);
    for (uint32_t i = 0; i < num_tables; i++) {
        struct acl_table* table = &handle->acl_tables[i];
        sx_acl_rule_offset_t offset;
        get_exact_offset_internal(table, &offset);
        if (c<len) {
           c += snprintf(buffer+c, len-c, "[%i] rules for %s:\n", i, table->table_name);
        }
        uint32_t rules_cnt = 0;
        sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, &offset, NULL, &rules_cnt);
        if (c<len) {
           c += snprintf(buffer+c,len-c, "  Rule key types: ");
        }
        for (uint32_t j=0; j < table->key_count; j++) {
            if (c<len) {
               c += snprintf(buffer+c,len-c, "  %i, ", table->key_list[j]);
            }
        }
        sx_acl_rule_offset_t offsets[100];
        for (uint32_t j=0; j <= offset; j++) {
            offsets[j] = j;
        }
        sx_flex_acl_flex_rule_t* rules = (sx_flex_acl_flex_rule_t*)malloc(rules_cnt*sizeof(sx_flex_acl_flex_rule_t));
        memset(rules, 0, rules_cnt*sizeof(sx_flex_acl_flex_rule_t));
        sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, offsets, rules, &rules_cnt);
        if (c<len) {
            c += snprintf(buffer+c,len-c, "\n  %d valid rules.\n", rules_cnt);
        }
        for (uint32_t k=0; k<rules_cnt; k++) {
            if (get_bitmap(table->valid_offsets, k) == 1) {
                if (c<len) {
                    c += snprintf(buffer+c, len-c, "#%i ", k);
                }
                for (uint32_t j=0; j < rules[k].key_desc_count; j++) {
                    if (rules[k].key_desc_list_p != 0) {
                        if (rules[k].key_desc_list_p[j].key_id == FLEX_ACL_KEY_DIP ||
                                rules[k].key_desc_list_p[j].key_id == FLEX_ACL_KEY_SIP) {
                            if (c<len) {
                                c += snprintf(buffer+c,len-c, "\tkey %s  ", inet_ntoa(rules[k].key_desc_list_p[j].key.dip.addr.ipv4));
                            }
                            if (c<len) {
                                c += snprintf(buffer+c,len-c, "\tmask %s\n", inet_ntoa(rules[k].key_desc_list_p[j].mask.dip.addr.ipv4));
                            }
                        }
                        else {
                            if (c<len) {
                                c += snprintf(buffer+c,len-c, "\tkey 0x%x  \tmask 0x%x\n",
                                    (uint32_t)rules[k].key_desc_list_p[j].key.src_port,(uint32_t)rules[k].key_desc_list_p[j].mask.vni_key);
                            }
                        }
                    }
                }
                for (uint32_t j=0; j < rules[k].action_count; j++) {
                    if (rules[k].action_list_p != 0) {
                        if (c<len) {
                            c += snprintf(buffer+c,len-c, "\taction 0x%x  \tparam 0x%x\n",
                                (uint32_t)rules[k].action_list_p[j].type, (uint32_t)rules[k].action_list_p[j].fields.action_counter.counter_id);
                        }
                    }
                }
                uint64_t bytes, packets = 0;
                fx_table_rule_counter_read(handle, table->table_id, k, &bytes, &packets);
                if (c<len) {
                   c += snprintf(buffer+c,len-c, "\tbytes: %" PRIu64 " packets: %" PRIu64 "\n", bytes, packets);
                }
            }
        }
        free(rules);
    }
}

void fx_table_deinit_keys(fx_handle_t handle, fx_table_id_t table_id, fx_key_list_t keys[], size_t rule_cnt) {
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) {
      FX_LOG(SX_LOG_ERROR, "Getting table index from id %d [fx_table_init_keys]\n", table_id);
      return;
  }
 
  // TODO action enum to id 
  return((*fx_table_x_deinit_keys_fn[table_index])(keys, rule_cnt) );
}

void fx_table_init_keys(fx_handle_t handle, fx_table_id_t table_id, fx_key_list_t keys[], size_t rule_cnt) {
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) {
      FX_LOG(SX_LOG_ERROR, "Getting table index from id %d [fx_table_init_keys]\n", table_id);
      return;
  }
  // TODO action enum to id 
  return((*fx_table_x_init_keys_fn[table_index])(keys, rule_cnt) );
}

sx_status_t
create_acl_pbs_id(fx_handle_t handle, const sx_acl_pbs_entry_type_t type, const uint16_t *label_port_list, const uint32_t port_cnt, sx_acl_pbs_id_t *pbs_id)
{
    sx_status_t rc = SX_STATUS_SUCCESS;
    sx_port_id_t port_id_list[port_cnt];
    for (unsigned int i = 0; i < port_cnt; i++) {
        rc = fx_logical_port_get(handle, label_port_list[i], &port_id_list[i]);
        if (rc) {
            FX_LOG(SX_LOG_ERROR, "Invalid port for policy based switching ACL, port 0x%x failed: [%s]\n", label_port_list[i], SX_STATUS_MSG(rc));
            return rc;
        }
    }
    // create PBS port id from port ID
    sx_acl_pbs_entry_t pbs_entry = {
            .entry_type = type,
            .port_num = port_cnt,
            .log_ports = &port_id_list[0]
    };
    const sx_swid_t swid = 0;
    rc = sx_api_acl_policy_based_switching_set(handle->sdk_handle,
            SX_ACCESS_CMD_ADD, swid, &pbs_entry, pbs_id);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "SDK API sx_api_acl_policy_based_switching_set for port 0x%x failed: [%s]\n", port_id_list[0], SX_STATUS_MSG(rc));
    }
    else {
        for (unsigned int i = 0; i < port_cnt; i++) {
            handle->pbs_id_table[type][label_port_list[i]] = *pbs_id;
        }
    }
    return rc;
}

/* clean up PBS ID resource
 * Can only be done after ACL using it has been removed
 */
sx_status_t
fx_action_acl_pbs_ids_delete(fx_handle_t handle)
{
    const sx_swid_t swid = 0;
    sx_status_t rc = SX_STATUS_SUCCESS;
    for (unsigned int type = 0; type <= SX_ACL_PBS_ENTRY_TYPE_MAX; type++) {
        for (uint32_t label_port = MIN_LABEL_PORT_INDEX; label_port < MAX_LABEL_PORT_INDEX; label_port++) {
            sx_acl_pbs_id_t pbs_id = handle->pbs_id_table[type][label_port];
            sx_port_id_t port_id;
            rc = fx_logical_port_get(handle, label_port, &port_id);
            const sx_acl_pbs_entry_type_t pbs_type = (sx_acl_pbs_entry_type_t)type;
            sx_acl_pbs_entry_t pbs_entry = {
                    .entry_type = pbs_type,
                    .port_num = 1,
                    .log_ports = &port_id
            };
            if (pbs_id != SX_ACL_PBS_ID_INVALID) {
                rc = sx_api_acl_policy_based_switching_set(handle->sdk_handle,
                        SX_ACCESS_CMD_DELETE, swid, &pbs_entry, &pbs_id);
                if (rc) {
                    // PBS ID to label port is 1 to many. So may get multiple calls to delete
                    FX_LOG(SX_LOG_WARNING, "Delete of policy_based_switching for label port %u failed: [%s]\n", port_id, SX_STATUS_MSG(rc));
                }
            }
        }
    }
    return rc;
}

/*
 * For now, expose only a minimal set of session params
 * And store the session ID in a local table
 * All supporting parameters must come after the conversion params
 */
sx_status_t
create_span_l3_session_id(fx_handle_t handle,
        const sx_span_type_t      type,
        const uint16_t*           label_port_list,   /* convert from */
        const uint32_t            port_cnt,
        sx_span_session_id_t*     span_session_id_p, /* convert to */
        const uint16_t            is_truncated,      /* optional = 0 */
        const uint16_t            truncate_size,     /* optional = 0 */
        const uint8_t*            dmac,
        const uint8_t*            smac,
        const in_addr_t           dest_ip,
        const in_addr_t           src_ip,
        const sx_vlan_id_t        vid)
{
    sx_status_t rc = SX_STATUS_SUCCESS;
    sx_port_id_t analyzer_log_port[port_cnt];
    for (unsigned int i = 0; i < port_cnt; i++) {
        rc = fx_logical_port_get(handle, label_port_list[i], &analyzer_log_port[i]);
        if (rc) {
            FX_LOG(SX_LOG_ERROR, "Invalid port for L3 span session, port 0x%x failed: [%s]\n", label_port_list[i], SX_STATUS_MSG(rc));
            return rc;
        }
    }

    sx_span_session_params_t session_params = {
      .span_type=type,
      .span_type_format.remote_eth_l3_type1={
        .qos_mode = SX_SPAN_QOS_MAINTAIN,
        .switch_prio = 2,
        .vid = 1,
        .vlan_ethertype_id = 0,
        .pcp = 3,
        .dei = 1,
        .tp = 1,
        .dscp = 0,
        .ecn = 0,
        .ttl = 64,
    //    .mac = ,
    //    .smac = ,
    //    .dest_ip = ,
    //    .src_ip = ,
      },
      .truncate = is_truncated ? 1 : 0,                   /**< Truncate the packet to 64 byte size */
      .truncate_size = is_truncated ? truncate_size : 0   /**<Truncation size if enabled - Spectrum only */
    };

    memcpy(&session_params.span_type_format.remote_eth_l3_type1.smac, smac, sizeof(sx_mac_addr_t));
    memcpy(&session_params.span_type_format.remote_eth_l3_type1.mac, dmac, sizeof(sx_mac_addr_t));
    memcpy(&session_params.span_type_format.remote_eth_l3_type1.src_ip.addr, &src_ip, sizeof(sx_ip_v4_addr_t));
    memcpy(&session_params.span_type_format.remote_eth_l3_type1.dest_ip.addr, &dest_ip, sizeof(sx_ip_v4_addr_t));
    session_params.span_type_format.remote_eth_l3_type1.src_ip.version = SX_IP_VERSION_IPV4;
    session_params.span_type_format.remote_eth_l3_type1.dest_ip.version = SX_IP_VERSION_IPV4;
    session_params.span_type_format.remote_eth_l3_type1.vid = vid;

    rc = sx_api_span_session_set(handle->sdk_handle, SX_ACCESS_CMD_CREATE,
            &session_params, span_session_id_p);
    if (rc) {
        FX_LOG(SX_LOG_ERROR,"Creating span session failed: [%s]\n", SX_STATUS_MSG(rc));
        goto SPAN_DONE;
    }

    FX_LOG(SX_LOG_INFO, "created span session id: %d.\n", *span_session_id_p);

    sx_span_analyzer_port_params_t analyzer_params = {
            .cng_mng = SX_SPAN_CNG_MNG_DONT_DISCARD
    };

    for (unsigned int i = 0; i < port_cnt; i++) {
        rc = sx_api_span_analyzer_set(handle->sdk_handle, SX_ACCESS_CMD_ADD , analyzer_log_port[i], &analyzer_params, *span_session_id_p);
        if (rc) {
            FX_LOG(SX_LOG_ERROR,"Add analyzer port to span session failed: [%s]\n", SX_STATUS_MSG(rc));
            goto RM_SPAN_SESSION;
        }

        rc = sx_api_span_session_state_set(handle->sdk_handle, *span_session_id_p, 1);
        if (rc) {
            FX_LOG(SX_LOG_ERROR,"Set span state enable failed: [%s]\n", SX_STATUS_MSG(rc));
            goto RM_MRR;
        }

        sx_port_log_id_t ingress_log_port = SX_INVALID_PORT;
//        if (ingress_port != 0) {
//            rc = fx_logical_port_get(handle, ingress_port, &ingress_log_port);
//            rc = sx_api_span_mirror_set(handle->sdk_handle,
//                    SX_ACCESS_CMD_ADD, ingress_log_port, SX_SPAN_MIRROR_INGRESS, *span_session_id_p);
//            if (rc) {
//                FX_LOG(SX_LOG_ERROR,"span ingress dir port failed: [%s]\n", SX_STATUS_MSG(rc));
//                goto RM_MRR;
//            }
//        }

        sx_port_log_id_t egress_log_port = SX_INVALID_PORT;
//        if (egress_port != 0) {
//            rc = fx_logical_port_get(handle, egress_port, &egress_log_port);
//            rc = sx_api_span_mirror_set(handle->sdk_handle,
//                    SX_ACCESS_CMD_ADD, egress_log_port, SX_SPAN_MIRROR_EGRESS, *span_session_id_p);
//            if (rc) {
//                FX_LOG(SX_LOG_ERROR,"span egress dir port failed: [%s]\n", SX_STATUS_MSG(rc));
//                goto RM_MRR;
//            }
//        }

        handle->span_session_table[label_port_list[i]].session_id = *span_session_id_p;
        handle->span_session_table[label_port_list[i]].ingress = ingress_log_port;
        handle->span_session_table[label_port_list[i]].egress = egress_log_port;
        FX_LOG(SX_LOG_INFO, "Created span session, id = %d on analyzer logical port 0x%x\n", *span_session_id_p, analyzer_log_port[i]);
    }
    FX_LOG(SX_LOG_INFO, "Assigned span session to %d ports.\n", port_cnt);
    goto SPAN_DONE;

    // in case somthing went wrong, free all resources.
    RM_MRR:
    for (unsigned int i = 0; i < port_cnt; i++) {
        sx_api_span_analyzer_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, analyzer_log_port[i], &analyzer_params, *span_session_id_p);
    }
    FX_LOG(SX_LOG_ERROR,"Removed span analyzer\n");

    RM_SPAN_SESSION:
    sx_api_span_session_set(handle->sdk_handle, SX_ACCESS_CMD_DESTROY, &session_params, span_session_id_p);
    FX_LOG(SX_LOG_ERROR,"Removed span session\n");

    SPAN_DONE:
    return (rc);
}

sx_status_t
create_span_v2_l3_session_id(fx_handle_t handle,
        const sx_span_type_t      type,
        const uint16_t*           label_port_list,   /* convert from */
        const uint32_t            port_cnt,
        sx_span_session_id_t*     span_session_id_p, /* convert to */
        const uint16_t            is_truncated,      /* optional = 0 */
        const uint16_t            truncation_size,       /* optional = 0 */
        const uint8_t*            dmac,
        const uint8_t*            smac,
        const in_addr_t           dest_ip,
        const in_addr_t           src_ip,
        const sx_vlan_id_t        vid)
{
    sx_status_t rc = create_span_l3_session_id(handle, type, label_port_list, port_cnt, span_session_id_p, is_truncated, truncation_size, dmac, smac, dest_ip, src_ip, vid);
    // Liberal hack - until SDK suppots this
    fx_span_header_type_set(FX_SPAN_HEADER_TYPE_V2, FX_SPAN_SESSION_ALL);
    return rc;
}

/* clean up SPAN ID resource
 * Can only be done after ACL using it has been removed
 */
sx_status_t
fx_action_span_sessions_delete(fx_handle_t handle)
{
    sx_status_t rc = SX_STATUS_SUCCESS;

    sx_span_session_params_t session_params = {
      .span_type=SX_SPAN_TYPE_REMOTE_ETH_L3_TYPE1,
      .span_type_format.remote_eth_l3_type1={
        .qos_mode = SX_SPAN_QOS_MAINTAIN,
        .switch_prio = 2,
        .vid = 1,
        .vlan_ethertype_id = 0,
        .pcp = 3,
        .dei = 1,
        .tp = 1,
        .dscp = 0,
        .ecn = 0,
        .ttl = 64,
    //    .mac = ,
    //    .smac = ,
    //    .dest_ip = ,
    //    .src_ip = ,
      },
      .truncate = 0,
      .truncate_size = 0
    };

    sx_span_analyzer_port_params_t analyzer_params = {
            .cng_mng = SX_SPAN_CNG_MNG_DONT_DISCARD
    };

    for (uint32_t label_port = MIN_LABEL_PORT_INDEX; label_port < MAX_LABEL_PORT_INDEX; label_port++) {
        sx_span_session_id_t span_id = handle->span_session_table[label_port].session_id;
        sx_port_id_t ingress = handle->span_session_table[label_port].ingress;
        sx_port_id_t egress = handle->span_session_table[label_port].egress;
        if (span_id != SPAN_SESSION_INVALID) {
            sx_port_id_t analyzer_log_port;
            sx_status_t rc = fx_logical_port_get(handle, label_port, &analyzer_log_port);
            if (rc) {
                FX_LOG(SX_LOG_WARNING, "Invalid port for L3 span session, port 0x%x failed: [%s]\n", label_port, SX_STATUS_MSG(rc));
                continue;
            }
            if (egress != SX_INVALID_PORT) {
                rc = sx_api_span_mirror_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, egress, SX_SPAN_MIRROR_EGRESS, span_id);
            }
            if (ingress != SX_INVALID_PORT) {
                rc = sx_api_span_mirror_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, ingress, SX_SPAN_MIRROR_INGRESS, span_id);
            }
            rc = sx_api_span_session_state_set(handle->sdk_handle, span_id, 0);
            rc = sx_api_span_analyzer_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, analyzer_log_port, &analyzer_params, span_id);
            rc = sx_api_span_session_set(handle->sdk_handle, SX_ACCESS_CMD_DESTROY, &session_params, &span_id);
        }
    }
    return rc;
}

sx_status_t check_action_params(fx_param_list_t params, fx_action_id_t action_id) {
  /* CHECK ACTION PARAMS */
	switch(action_id){
		case 16786535: /* CONTROL_IN_RIF_SET_METADATA_ID */
		{
          if (params.len != 1) {
            FX_LOG(SX_LOG_ERROR,"Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.set_metadata\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
	    break;
		}
		case 16825799: /* CONTROL_IN_RIF_TO_NEXTHOP_ID */
		{
          if (params.len != 1) {
            FX_LOG(SX_LOG_ERROR,"Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.to_nexthop\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
	    break;
		}
		case 16812468: /* CONTROL_OUT_RIF_TUNNEL_ENCAP_ID */
		{
          if (params.len != 3) {
            FX_LOG(SX_LOG_ERROR,"Got invalid parameters list of length %zu while expecting 3 in action control_out_rif.tunnel_encap\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
	    break;
		}
		case 16841981: /* CONTROL_IN_RIF_TO_LOCAL_ID */
		{
          if (params.len != 1) {
            FX_LOG(SX_LOG_ERROR,"Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.to_local\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
	    break;
		}
		default: {}
    }
  /* CHECK ACTION PARAMS */
   return SX_STATUS_SUCCESS;
}

void reverse_bytes(uint8_t head[], size_t len) {
    uint8_t temp;
    for (uint32_t i=0; i<len/2; i++) {
        temp = head[i];
        head[i] = head[len-i-1];
        head[len-i-1] = temp;
    }
}

/*
 * Build the ACL rule action list using the parameter data provided. The P4
 * Compiler must verify that the action is valid for a given pipeline stage,
 * as no runtime check is performed (e.g. using an in_rif only action at the in_port stage).
*/
bool set_action_list(fx_handle_t handle, int action_id, fx_param_list_t params, struct acl_table *table, sx_acl_rule_offset_t* offset_ptr, sx_flex_acl_flex_rule_t* rule ) {
	if (rule->action_list_p == NULL) { FX_LOG(SX_LOG_ERROR, "Flex action uninitialized (sx_lib_flex_acl_rule_init)"); return false;}
	switch(action_id) { // 6 unique actions out of 8 action invocations
		case 16778278: /* CONTROL_IN_RIF_DROP_ID */
		{
			// mlnx_drop() 
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_FORWARD,
				.fields.action_forward.action = (sx_flex_acl_forward_action_t) SX_ACL_TRAP_FORWARD_ACTION_TYPE_DISCARD,
			};
			// hit_counter() 
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case 16786535: /* CONTROL_IN_RIF_SET_METADATA_ID */
		{
			// set_inrif1_reg32(in_rif_metadata, 0xffffffff) 
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_SET_DST_MAC,
			/*	.fields.action_set_dst_mac.mac = *(uint8_t*)(params.params[0].data), */
			};
			{
			if (4 > params.params[0].len) { FX_LOG(SX_LOG_ERROR,"ERROR in action parameter size"); }
			uint8_t* mac = (uint8_t*)(&rule->action_list_p[0].fields.action_set_dst_mac.mac);
			memcpy(&mac[0], params.params[0].data, 4);
			}
			// hit_counter() 
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case 16825799: /* CONTROL_IN_RIF_TO_NEXTHOP_ID */
		{
			// set_remote_uc_route(next_hop) 
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_UC_ROUTE,
			/*	.fields.action_uc_route.uc_route_param.ecmp_id = *(sx_ecmp_id_t*)(params.params[0].data), */
				.fields.action_uc_route.uc_route_type = (sx_uc_route_type_e) SX_UC_ROUTE_TYPE_NEXT_HOP,
			};
			{
			memcpy(&rule->action_list_p[0].fields.action_uc_route.uc_route_param.ecmp_id, params.params[0].data, params.params[0].len);
			}
			// hit_counter() 
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case 16812468: /* CONTROL_OUT_RIF_TUNNEL_ENCAP_ID */
		{
			// set_dst_mac(dst_mac) 
            rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
                .type =  SX_FLEX_ACL_ACTION_SET_DST_MAC,
                /*.fields.action_set_dst_mac.mac = *(uint8_t*)(params.params[2].data)*/
			};
			{
            memcpy(&rule->action_list_p[0].fields.action_set_dst_mac.mac, params.params[0].data, params.params[0].len);
			}
			// vxlan_tunnel_encap(tunnel_id, underlay_dip) 
            rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_NVE_TUNNEL_ENCAP,
                .fields.action_nve_tunnel_encap.tunnel_id = *(sx_tunnel_id_t*)(params.params[1].data),
                .fields.action_nve_tunnel_encap.underlay_dip.addr.ipv4.s_addr = *(in_addr_t*)(params.params[2].data),
                .fields.action_nve_tunnel_encap.underlay_dip.version = (sx_ip_version_t) SX_IP_VERSION_IPV4
			};
			{
            memcpy(&rule->action_list_p[1].fields.action_nve_tunnel_encap.tunnel_id, params.params[1].data, params.params[1].len);
			}
			{
            memcpy(&rule->action_list_p[1].fields.action_nve_tunnel_encap.underlay_dip.addr.ipv4.s_addr, params.params[2].data, params.params[2].len);
			}
			// hit_counter() 
			rule->action_list_p[2] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case 16800567: /* NOACTION_ID */
		{
			break;
		};
		case 16841981: /* CONTROL_IN_RIF_TO_LOCAL_ID */
		{
			// set_local_uc_route(router_interface) 
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_UC_ROUTE,
			/*	.fields.action_uc_route.uc_route_param.local_egress_rif = *(sx_router_interface_t*)(params.params[0].data), */
				.fields.action_uc_route.uc_route_type = (sx_uc_route_type_e) SX_UC_ROUTE_TYPE_LOCAL,
			};
			{
			memcpy(&rule->action_list_p[0].fields.action_uc_route.uc_route_param.local_egress_rif, params.params[0].data, params.params[0].len);
			}
			// hit_counter() 
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case 0: /* FX_ACTION_INVALID_ID */
		default:
			FX_LOG(SX_LOG_ERROR,"Requested action is not in the action list: action ID %i\n",action_id);
	}
	return true;
}
sx_status_t fx_actions_init(fx_handle_t handle) {
    return SX_STATUS_SUCCESS;
}

sx_status_t fx_actions_deinit(fx_handle_t handle) {
    return SX_STATUS_SUCCESS;
}

// --------------- control_in_rif_table_bitmap_classification ------------
/************** per table APIs **************/
void fill_custom_bytes_control_in_rif_table_bitmap_classification(struct fx_custom_params *custom) {
  if (custom->is_cb) {
      custom->attr.extraction_points_count = 1;
      custom->attr.extraction_point.extraction_group_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_GROUP_L2;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.extraction_point_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_POINT_TYPE_L2_NONE;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.offset= custom->cb_offset;
  }
}

sx_status_t create_control_in_rif_table_bitmap_classification(fx_handle_t handle, sx_acl_id_t* pipe_id_list, int pipe_ind  ) {
  const uint32_t size = 128;
  const uint32_t key_count = 1;
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  table->table_id = CONTROL_IN_RIF_TABLE_BITMAP_CLASSIFICATION_ID;
  table->default_entry_offset= 127;
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_classification(&custom);
  table->table_size = size;
  table->key_count = key_count;
  FX_LOG(SX_LOG_INFO, "create_control_in_rif_table_bitmap_classification. size=%d keys=%d\n", table->table_size, table->key_count);
  table->key_list = (sx_acl_key_t*) malloc(sizeof(sx_acl_key_t) * table->key_count);
  if (table->key_list == NULL){
    FX_LOG(SX_LOG_ERROR, "In create_control_in_rif_table_bitmap_classification: %s\n","No memory to create key list");
    return SX_STATUS_NO_MEMORY;
  } 
  table->pipe_line = SX_ACL_DIRECTION_RIF_INGRESS; // replaced with pipeline (hook location)
  strncpy(table->table_name, "control_in_rif_table_bitmap_classification", MAX_TABLE_NAME_LEN);

  /* Key assignment includes custom bytes - for CB SDK should allow P4C to provide a hint */
  /* KEY ASSIGN START */
  table->key_list[0] = FLEX_ACL_KEY_VIRTUAL_ROUTER;
  /* KEY ASSIGN END */

  sx_status_t rc =  create_p4_table(handle, table, &custom);
  if (rc) {
     FX_LOG(SX_LOG_ERROR, "Create_control_in_rif_table_bitmap_classification, table #%d with acl ID %d\n", table_index, table->acl_id);
     return rc;
  } else {
      FX_LOG(SX_LOG_INFO, "create_control_in_rif_table_bitmap_classification, table #%d with acl ID %d\n", table_index, table->acl_id);
  }
	table->range_table = NULL;  
  pipe_id_list[pipe_ind] = table->acl_id;

  fx_table_entry_const_set(handle,table);

  return SX_STATUS_SUCCESS;
}

sx_status_t delete_control_in_rif_table_bitmap_classification(fx_handle_t handle) {
  FX_LOG(SX_LOG_INFO, "Delete_control_in_rif_table_bitmap_classification. \n");
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_classification(&custom);
  sx_status_t rc = delete_p4_table(handle, table, &custom);
  free(table->key_list);
  table->key_list = 0;
  if (rc) {
    FX_LOG(SX_LOG_ERROR, "Delete_control_in_rif_table_bitmap_classification, table #%d with acl ID %d\n", table_index, table->acl_id);
    return rc;
  }
  return SX_STATUS_SUCCESS;
}



sx_status_t fx_control_in_rif_table_bitmap_classification_default_entry_set(fx_handle_t handle, struct acl_table *table, fx_param_list_t params,int action_id){
  sx_acl_rule_offset_t offset  = table->default_entry_offset;
  sx_acl_rule_offset_t *offset_ptr = &offset;
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  sx_flex_acl_flex_rule_t default_rule;
  sx_flex_acl_flex_rule_t *rule = &default_rule;
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_in_rif_table_bitmap_classification index %d\n",offset);
  /* __TABLE_DEFAULT_ENTRY_KEYS_||_ */
  rule->key_desc_list_p = NULL;
  rule->key_desc_count = 0;
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}


sx_status_t check_input_lengths_control_in_rif_table_bitmap_classification(fx_key_list_t keys, fx_param_list_t params, fx_action_id_t action_id) {
  /* TABLE_CHECK_KEYS_PARAMS START */
  if (keys.len != 1) {
    FX_LOG(SX_LOG_ERROR,"Got invalid keys length %zu while expecting 1, in table control_in_rif.table_bitmap_classification\n", keys.len);
    return SX_STATUS_PARAM_ERROR;
  }

  /* Key #0: FLEX_ACL_KEY_VIRTUAL_ROUTER */
  if (keys.keys[0].key.data != NULL) {
    if (keys.keys[0].key.len != sizeof(sx_router_id_t)) {
      FX_LOG(SX_LOG_ERROR,"Got key (0) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_classification\n", keys.keys[0].key.len, sizeof(sx_router_id_t));
      return SX_STATUS_PARAM_ERROR;
    }
  }

  /* TABLE_CHECK_KEYS_PARAMS END */
    return check_action_params(params, action_id);
}

void fx_init_key_list_control_in_rif_table_bitmap_classification(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
  /* INIT RULE START */
      key_lists[i].len = 1;
      key_lists[i].keys = (fx_key_t*) malloc(1 * sizeof(fx_key_t));
      key_lists[i].keys[0].key.data = NULL;
      key_lists[i].keys[0].mask.data = NULL;
  /* INIT RULE END */
    }
}

void fx_deinit_key_list_control_in_rif_table_bitmap_classification(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
        free(key_lists[i].keys);
    }
}

sx_status_t add_table_entry_control_in_rif_table_bitmap_classification_internal(fx_handle_t handle,struct acl_table *table, sx_flex_acl_flex_rule_t *rule, fx_key_list_t keys,fx_param_list_t params, fx_action_id_t action_id, sx_acl_rule_offset_t* offset_ptr)
{
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_in_rif_table_bitmap_classification index %d\n",*offset_ptr);
  /* TABLE ENTRY KEYS START */
  /* sx_lib_flex_acl_rule_init allocated 1 * sizeof(sx_flex_acl_key_desc_t) bytes */
  int curr_key=0;
  if (keys.keys[0].key.data != NULL) { /* Key #0: virtual_router */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[0],
      };
      rule->key_desc_list_p[curr_key].key_id=table->key_list[0];
      memcpy(&rule->key_desc_list_p[curr_key].key.virtual_router, keys.keys[0].key.data, keys.keys[0].key.len);
      memset(&rule->key_desc_list_p[curr_key].mask.virtual_router, 0x00, keys.keys[0].key.len); // exact match
      rule->key_desc_list_p[curr_key].mask.virtual_router = 0x01;
      ++curr_key;
  }
  rule->key_desc_count=curr_key; /* key count 1 */
  /* TABLE ENTRY KEYS END */
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}

/* API for the CLI app - This can be made to be more user friendly */
sx_status_t add_table_entry_control_in_rif_table_bitmap_classification(fx_handle_t handle, fx_action_id_t action_id, fx_key_list_t keys,fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  /* EXACT OFFSET START */
  get_exact_offset_internal(table, offset_ptr);
  /* EXACT OFFSET END */
  sx_status_t           rc = SX_STATUS_SUCCESS;
  sx_flex_acl_flex_rule_t rule = {0};
  rc = check_input_lengths_control_in_rif_table_bitmap_classification(keys, params, action_id);
  if (rc) return rc;
  /* Convert keys and mask from user friendly format to machine friendly here */
  rc = add_table_entry_control_in_rif_table_bitmap_classification_internal(handle,table,&rule,keys,params,action_id, offset_ptr);
  return rc;
}

sx_status_t remove_table_entry_control_in_rif_table_bitmap_classification(fx_handle_t handle, sx_acl_rule_offset_t offset){
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  FX_LOG(SX_LOG_INFO, "remove rule from control_in_rif_table_bitmap_classification, offset =  %d\n",offset);
  return remove_table_entry(handle,table, offset);
}


// --------end of control_in_rif_table_bitmap_classification----------------

// --------------- control_in_rif_table_bitmap_router ------------
/************** per table APIs **************/
void fill_custom_bytes_control_in_rif_table_bitmap_router(struct fx_custom_params *custom) {
  if (custom->is_cb) {
      custom->attr.extraction_points_count = 1;
      custom->attr.extraction_point.extraction_group_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_GROUP_L2;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.extraction_point_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_POINT_TYPE_L2_NONE;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.offset= custom->cb_offset;
  }
}

sx_status_t create_control_in_rif_table_bitmap_router(fx_handle_t handle, sx_acl_id_t* pipe_id_list, int pipe_ind  ) {
  const uint32_t size = 512;
  const uint32_t key_count = 2;
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  table->table_id = CONTROL_IN_RIF_TABLE_BITMAP_ROUTER_ID;
  table->default_entry_offset= 511;
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_router(&custom);
  table->table_size = size;
  table->key_count = key_count;
  FX_LOG(SX_LOG_INFO, "create_control_in_rif_table_bitmap_router. size=%d keys=%d\n", table->table_size, table->key_count);
  table->key_list = (sx_acl_key_t*) malloc(sizeof(sx_acl_key_t) * table->key_count);
  if (table->key_list == NULL){
    FX_LOG(SX_LOG_ERROR, "In create_control_in_rif_table_bitmap_router: %s\n","No memory to create key list");
    return SX_STATUS_NO_MEMORY;
  } 
  table->pipe_line = SX_ACL_DIRECTION_RIF_INGRESS; // replaced with pipeline (hook location)
  strncpy(table->table_name, "control_in_rif_table_bitmap_router", MAX_TABLE_NAME_LEN);

  /* Key assignment includes custom bytes - for CB SDK should allow P4C to provide a hint */
  /* KEY ASSIGN START */
  table->key_list[0] = FLEX_ACL_KEY_DMAC;
  table->key_list[1] = FLEX_ACL_KEY_DIP;
  /* KEY ASSIGN END */

  sx_status_t rc =  create_p4_table(handle, table, &custom);
  if (rc) {
     FX_LOG(SX_LOG_ERROR, "Create_control_in_rif_table_bitmap_router, table #%d with acl ID %d\n", table_index, table->acl_id);
     return rc;
  } else {
      FX_LOG(SX_LOG_INFO, "create_control_in_rif_table_bitmap_router, table #%d with acl ID %d\n", table_index, table->acl_id);
  }
	table->range_table = NULL;  
  pipe_id_list[pipe_ind] = table->acl_id;

  fx_table_entry_const_set(handle,table);

  return SX_STATUS_SUCCESS;
}

sx_status_t delete_control_in_rif_table_bitmap_router(fx_handle_t handle) {
  FX_LOG(SX_LOG_INFO, "Delete_control_in_rif_table_bitmap_router. \n");
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_router(&custom);
  sx_status_t rc = delete_p4_table(handle, table, &custom);
  free(table->key_list);
  table->key_list = 0;
  if (rc) {
    FX_LOG(SX_LOG_ERROR, "Delete_control_in_rif_table_bitmap_router, table #%d with acl ID %d\n", table_index, table->acl_id);
    return rc;
  }
  return SX_STATUS_SUCCESS;
}



sx_status_t fx_control_in_rif_table_bitmap_router_default_entry_set(fx_handle_t handle, struct acl_table *table, fx_param_list_t params,int action_id){
  sx_acl_rule_offset_t offset  = table->default_entry_offset;
  sx_acl_rule_offset_t *offset_ptr = &offset;
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  sx_flex_acl_flex_rule_t default_rule;
  sx_flex_acl_flex_rule_t *rule = &default_rule;
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_in_rif_table_bitmap_router index %d\n",offset);
  /* __TABLE_DEFAULT_ENTRY_KEYS_||_ */
  rule->key_desc_list_p = NULL;
  rule->key_desc_count = 0;
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}


sx_status_t check_input_lengths_control_in_rif_table_bitmap_router(fx_key_list_t keys, fx_param_list_t params, fx_action_id_t action_id) {
  /* TABLE_CHECK_KEYS_PARAMS START */
  if (keys.len != 2) {
    FX_LOG(SX_LOG_ERROR,"Got invalid keys length %zu while expecting 2, in table control_in_rif.table_bitmap_router\n", keys.len);
    return SX_STATUS_PARAM_ERROR;
  }

  /* Key #0: DERIVED_IN_RIF1_REG32 */
  if (keys.keys[0].key.data != NULL) {
    if (keys.keys[0].key.len != 4) {
      FX_LOG(SX_LOG_ERROR,"Got key (0) of length %zu while expecting 4, in table control_in_rif.table_bitmap_router\n", keys.keys[0].key.len);
      return SX_STATUS_PARAM_ERROR;
    }
  }

  /* Key #1: FLEX_ACL_KEY_DIP */
  if (keys.keys[1].key.data != NULL) {
    if (keys.keys[1].key.len != sizeof(in_addr_t)) {
      FX_LOG(SX_LOG_ERROR,"Got key (1) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_router\n", keys.keys[1].key.len, sizeof(in_addr_t));
      return SX_STATUS_PARAM_ERROR;
    }
    if (keys.keys[1].mask.data != NULL) {
      if (keys.keys[1].mask.len != sizeof(in_addr_t)) {
        FX_LOG(SX_LOG_ERROR,"Got mask (1) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_router\n", keys.keys[1].mask.len, sizeof(in_addr_t));
        return SX_STATUS_PARAM_ERROR;
      }
    }
  }

  /* TABLE_CHECK_KEYS_PARAMS END */
    return check_action_params(params, action_id);
}

void fx_init_key_list_control_in_rif_table_bitmap_router(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
  /* INIT RULE START */
      key_lists[i].len = 2;
      key_lists[i].keys = (fx_key_t*) malloc(2 * sizeof(fx_key_t));
      key_lists[i].keys[0].key.data = NULL;
      key_lists[i].keys[0].mask.data = NULL;
      key_lists[i].keys[1].key.data = NULL;
      key_lists[i].keys[1].mask.data = NULL;
  /* INIT RULE END */
    }
}

void fx_deinit_key_list_control_in_rif_table_bitmap_router(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
        free(key_lists[i].keys);
    }
}

sx_status_t add_table_entry_control_in_rif_table_bitmap_router_internal(fx_handle_t handle,struct acl_table *table, sx_flex_acl_flex_rule_t *rule, fx_key_list_t keys,fx_param_list_t params, fx_action_id_t action_id, sx_acl_rule_offset_t* offset_ptr)
{
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_in_rif_table_bitmap_router index %d\n",*offset_ptr);
  /* TABLE ENTRY KEYS START */
  /* sx_lib_flex_acl_rule_init allocated 2 * sizeof(sx_flex_acl_key_desc_t) bytes */
  int curr_key=0;
  if (keys.keys[0].key.data != NULL) { /* Key #0: dmac.ether_addr_octet */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[0],
      };
      rule->key_desc_list_p[curr_key].key_id=table->key_list[0];
      u_int8_t* tmp_key = (u_int8_t*)(&rule->key_desc_list_p[curr_key].key.dmac.ether_addr_octet);
      memcpy(&tmp_key[0], keys.keys[0].key.data, keys.keys[0].key.len);
      u_int8_t* tmp_mask = (u_int8_t*)(&rule->key_desc_list_p[curr_key].mask.dmac.ether_addr_octet);
      memset(&tmp_mask[0], 0xFF, keys.keys[0].key.len); // exact match
      ++curr_key;
  }
  if (keys.keys[1].key.data != NULL) { /* Key #1: dip.addr.ipv4.s_addr */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[1],
        .key.dip.version =SX_IP_VERSION_IPV4, 
        .mask.dip.version =SX_IP_VERSION_IPV4, 
      };
      rule->key_desc_list_p[curr_key].key_id=table->key_list[1];
      memcpy(&rule->key_desc_list_p[curr_key].key.dip.addr.ipv4.s_addr, keys.keys[1].key.data, keys.keys[1].key.len);
      memcpy(&rule->key_desc_list_p[curr_key].mask.dip.addr.ipv4.s_addr, keys.keys[1].mask.data, keys.keys[1].mask.len);
      ++curr_key;
  }
  rule->key_desc_count=curr_key; /* key count 2 */
  /* TABLE ENTRY KEYS END */
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}

/* API for the CLI app - This can be made to be more user friendly */
sx_status_t add_table_entry_control_in_rif_table_bitmap_router(fx_handle_t handle, fx_action_id_t action_id, fx_key_list_t keys,fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  /* EXACT OFFSET START */
  if(*offset_ptr == table->default_entry_offset){
    FX_LOG(SX_LOG_ERROR, "Add table entry: rule offset same as default entry offset: %u, skipping rule.\n",(unsigned int)*offset_ptr);
    return SX_STATUS_PARAM_ERROR;  }
  /* EXACT OFFSET END */
  sx_status_t           rc = SX_STATUS_SUCCESS;
  sx_flex_acl_flex_rule_t rule = {0};
  rc = check_input_lengths_control_in_rif_table_bitmap_router(keys, params, action_id);
  if (rc) return rc;
  /* Convert keys and mask from user friendly format to machine friendly here */
  rc = add_table_entry_control_in_rif_table_bitmap_router_internal(handle,table,&rule,keys,params,action_id, offset_ptr);
  return rc;
}

sx_status_t remove_table_entry_control_in_rif_table_bitmap_router(fx_handle_t handle, sx_acl_rule_offset_t offset){
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  FX_LOG(SX_LOG_INFO, "remove rule from control_in_rif_table_bitmap_router, offset =  %d\n",offset);
  return remove_table_entry(handle,table, offset);
}


// --------end of control_in_rif_table_bitmap_router----------------

// --------------- control_out_rif_table_meta_tunnel ------------
/************** per table APIs **************/
void fill_custom_bytes_control_out_rif_table_meta_tunnel(struct fx_custom_params *custom) {
  if (custom->is_cb) {
      custom->attr.extraction_points_count = 1;
      custom->attr.extraction_point.extraction_group_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_GROUP_L2;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.extraction_point_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_POINT_TYPE_L2_NONE;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.offset= custom->cb_offset;
  }
}

sx_status_t create_control_out_rif_table_meta_tunnel(fx_handle_t handle, sx_acl_id_t* pipe_id_list, int pipe_ind  ) {
  const uint32_t size = 4032;
  const uint32_t key_count = 1;
  const int table_index = 2; // 2 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  table->table_id = CONTROL_OUT_RIF_TABLE_META_TUNNEL_ID;
  table->default_entry_offset= 511;
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_out_rif_table_meta_tunnel(&custom);
  table->table_size = size;
  table->key_count = key_count;
  FX_LOG(SX_LOG_INFO, "create_control_out_rif_table_meta_tunnel. size=%d keys=%d\n", table->table_size, table->key_count);
  table->key_list = (sx_acl_key_t*) malloc(sizeof(sx_acl_key_t) * table->key_count);
  if (table->key_list == NULL){
    FX_LOG(SX_LOG_ERROR, "In create_control_out_rif_table_meta_tunnel: %s\n","No memory to create key list");
    return SX_STATUS_NO_MEMORY;
  } 
  table->pipe_line = SX_ACL_DIRECTION_RIF_EGRESS; // replaced with pipeline (hook location)
  strncpy(table->table_name, "control_out_rif_table_meta_tunnel", MAX_TABLE_NAME_LEN);

  /* Key assignment includes custom bytes - for CB SDK should allow P4C to provide a hint */
  /* KEY ASSIGN START */
  table->key_list[0] = FLEX_ACL_KEY_DMAC;
  /* KEY ASSIGN END */

  sx_status_t rc =  create_p4_table(handle, table, &custom);
  if (rc) {
     FX_LOG(SX_LOG_ERROR, "Create_control_out_rif_table_meta_tunnel, table #%d with acl ID %d\n", table_index, table->acl_id);
     return rc;
  } else {
      FX_LOG(SX_LOG_INFO, "create_control_out_rif_table_meta_tunnel, table #%d with acl ID %d\n", table_index, table->acl_id);
  }
	table->range_table = NULL;  
  pipe_id_list[pipe_ind] = table->acl_id;

  fx_table_entry_const_set(handle,table);

  return SX_STATUS_SUCCESS;
}

sx_status_t delete_control_out_rif_table_meta_tunnel(fx_handle_t handle) {
  FX_LOG(SX_LOG_INFO, "Delete_control_out_rif_table_meta_tunnel. \n");
  const int table_index = 2; // 2 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_out_rif_table_meta_tunnel(&custom);
  sx_status_t rc = delete_p4_table(handle, table, &custom);
  free(table->key_list);
  table->key_list = 0;
  if (rc) {
    FX_LOG(SX_LOG_ERROR, "Delete_control_out_rif_table_meta_tunnel, table #%d with acl ID %d\n", table_index, table->acl_id);
    return rc;
  }
  return SX_STATUS_SUCCESS;
}



sx_status_t fx_control_out_rif_table_meta_tunnel_default_entry_set(fx_handle_t handle, struct acl_table *table, fx_param_list_t params,int action_id){
  sx_acl_rule_offset_t offset  = table->default_entry_offset;
  sx_acl_rule_offset_t *offset_ptr = &offset;
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  sx_flex_acl_flex_rule_t default_rule;
  sx_flex_acl_flex_rule_t *rule = &default_rule;
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_out_rif_table_meta_tunnel index %d\n",offset);
  /* __TABLE_DEFAULT_ENTRY_KEYS_||_ */
  rule->key_desc_list_p = NULL;
  rule->key_desc_count = 0;
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}


sx_status_t check_input_lengths_control_out_rif_table_meta_tunnel(fx_key_list_t keys, fx_param_list_t params, fx_action_id_t action_id) {
  /* TABLE_CHECK_KEYS_PARAMS START */
  if (keys.len != 1) {
    FX_LOG(SX_LOG_ERROR,"Got invalid keys length %zu while expecting 1, in table control_out_rif.table_meta_tunnel\n", keys.len);
    return SX_STATUS_PARAM_ERROR;
  }

  /* Key #0: DERIVED_IN_RIF1_REG32 */
  if (keys.keys[0].key.data != NULL) {
    if (keys.keys[0].key.len != 4) {
      FX_LOG(SX_LOG_ERROR,"Got key (0) of length %zu while expecting 4, in table control_out_rif.table_meta_tunnel\n", keys.keys[0].key.len);
      return SX_STATUS_PARAM_ERROR;
    }
  }

  /* TABLE_CHECK_KEYS_PARAMS END */
    return check_action_params(params, action_id);
}

void fx_init_key_list_control_out_rif_table_meta_tunnel(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
  /* INIT RULE START */
      key_lists[i].len = 1;
      key_lists[i].keys = (fx_key_t*) malloc(1 * sizeof(fx_key_t));
      key_lists[i].keys[0].key.data = NULL;
      key_lists[i].keys[0].mask.data = NULL;
  /* INIT RULE END */
    }
}

void fx_deinit_key_list_control_out_rif_table_meta_tunnel(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (uint32_t i=0; i < rule_cnt; i++) {
        free(key_lists[i].keys);
    }
}

sx_status_t add_table_entry_control_out_rif_table_meta_tunnel_internal(fx_handle_t handle,struct acl_table *table, sx_flex_acl_flex_rule_t *rule, fx_key_list_t keys,fx_param_list_t params, fx_action_id_t action_id, sx_acl_rule_offset_t* offset_ptr)
{
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  FX_LOG(SX_LOG_INFO, "Insert rule to control_out_rif_table_meta_tunnel index %d\n",*offset_ptr);
  /* TABLE ENTRY KEYS START */
  /* sx_lib_flex_acl_rule_init allocated 1 * sizeof(sx_flex_acl_key_desc_t) bytes */
  int curr_key=0;
  if (keys.keys[0].key.data != NULL) { /* Key #0: dmac.ether_addr_octet */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[0],
      };
      rule->key_desc_list_p[curr_key].key_id=table->key_list[0];
      u_int8_t* tmp_key = (u_int8_t*)(&rule->key_desc_list_p[curr_key].key.dmac.ether_addr_octet);
      memcpy(&tmp_key[0], keys.keys[0].key.data, keys.keys[0].key.len);
      u_int8_t* tmp_mask = (u_int8_t*)(&rule->key_desc_list_p[curr_key].mask.dmac.ether_addr_octet);
      memset(&tmp_mask[0], 0xFF, keys.keys[0].key.len); // exact match
      ++curr_key;
  }
  rule->key_desc_count=curr_key; /* key count 1 */
  /* TABLE ENTRY KEYS END */
  // init action
  if (!set_action_list(handle, action_id, params, table, offset_ptr, rule )) {
       rc = SX_STATUS_PARAM_ERROR;
  }
  if (!rc) {
     rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  }
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}

/* API for the CLI app - This can be made to be more user friendly */
sx_status_t add_table_entry_control_out_rif_table_meta_tunnel(fx_handle_t handle, fx_action_id_t action_id, fx_key_list_t keys,fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  const int table_index = 2; // 2 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  /* EXACT OFFSET START */
  get_exact_offset_internal(table, offset_ptr);
  /* EXACT OFFSET END */
  sx_status_t           rc = SX_STATUS_SUCCESS;
  sx_flex_acl_flex_rule_t rule = {0};
  rc = check_input_lengths_control_out_rif_table_meta_tunnel(keys, params, action_id);
  if (rc) return rc;
  /* Convert keys and mask from user friendly format to machine friendly here */
  rc = add_table_entry_control_out_rif_table_meta_tunnel_internal(handle,table,&rule,keys,params,action_id, offset_ptr);
  return rc;
}

sx_status_t remove_table_entry_control_out_rif_table_meta_tunnel(fx_handle_t handle, sx_acl_rule_offset_t offset){
  const int table_index = 2; // 2 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  FX_LOG(SX_LOG_INFO, "remove rule from control_out_rif_table_meta_tunnel, offset =  %d\n",offset);
  return remove_table_entry(handle,table, offset);
}


// --------end of control_out_rif_table_meta_tunnel----------------

// -------------PIPE CODE CONTROL_IN_PORT -----------------------------------
// pipe: control_in_port
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_INGRESS
// type rif/port : port
// auto tables iteration over:
// if_list type: pptype
// fx pipe enum: FX_CONTROL_IN_PORT

static port_handle_type *control_in_port_bind_list = NULL;
static uint32_t control_in_port_bind_list_cnt = 0;

sx_status_t create_pipe_control_in_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_IN_PORT] + CONTROL_IN_PORT_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_IN_PORT];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (uint32_t i=0; i < handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_IN_PORT][i];
    for (uint32_t i=0; (int32_t)i < CONTROL_IN_PORT_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]] = handle->control_in_port_id_list[i];
	for (uint32_t i=0; i < handle->post_pipe_id_count[FX_CONTROL_IN_PORT]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]+CONTROL_IN_PORT_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_IN_PORT][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_INGRESS, acl_id_list, acl_id_count , &handle->control_in_port_group_id);
	if(rc) {
	    FX_LOG(SX_LOG_ERROR,"ERROR in creating control_in_port group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_in_port was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = port_bind(handle,handle->control_in_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc == SX_STATUS_RESOURCE_IN_USE) {
	    FX_LOG(SX_LOG_INFO, "Rebinding interface (was it already bound by the NOS?)\n");
	    rc = SX_STATUS_SUCCESS;
	}
	control_in_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_in_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_in_port_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_in_port(fx_handle_t handle){
    if (control_in_port_bind_list == 0 || control_in_port_bind_list_cnt ==0) return 0;
	sx_status_t rc1 = port_bind(handle, handle->control_in_port_group_id,(boolean_t) false, control_in_port_bind_list,control_in_port_bind_list_cnt);
	free(control_in_port_bind_list);
	control_in_port_bind_list = NULL;
	control_in_port_bind_list_cnt = 0;
	if (rc1) {
        FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_in_port group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_INGRESS , &handle->control_in_port_group_id);
	if (rc2) {
        FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_in_port group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	for (uint32_t i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_in_port was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_in_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = port_bind(handle, handle->control_in_port_group_id,(boolean_t) false, control_in_port_bind_list,control_in_port_bind_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_in_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_in_port_bind_list);
	control_in_port_bind_list = NULL;
	control_in_port_bind_list_cnt = 0;
	rc = port_bind(handle,handle->control_in_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in binding control_in_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_in_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_in_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_in_port_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_IN_RIF -----------------------------------
// pipe: control_in_rif
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_RIF_INGRESS
// type rif/port : rif
// auto tables iteration over:
// table name: control_in_rif_table_bitmap_classification ,  index : 0
// table name: control_in_rif_table_bitmap_router ,  index : 1
// if_list type: pptype
// fx pipe enum: FX_CONTROL_IN_RIF

static rif_handle_type *control_in_rif_bind_list = NULL;
static uint32_t control_in_rif_bind_list_cnt = 0;

sx_status_t create_pipe_control_in_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	if (create_control_in_rif_table_bitmap_classification(handle, handle->control_in_rif_id_list,0)){FX_LOG(SX_LOG_ERROR,"ERROR in creating control_in_rif, pipe table: control_in_rif_table_bitmap_classification\n"); return SX_STATUS_ERROR;}
	if (create_control_in_rif_table_bitmap_router(handle, handle->control_in_rif_id_list,1)){FX_LOG(SX_LOG_ERROR,"ERROR in creating control_in_rif, pipe table: control_in_rif_table_bitmap_router\n"); return SX_STATUS_ERROR;}
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_IN_RIF] + CONTROL_IN_RIF_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_IN_RIF];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (uint32_t i=0; i < handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_IN_RIF][i];
	for (uint32_t i=0; i < CONTROL_IN_RIF_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]] = handle->control_in_rif_id_list[i];
	for (uint32_t i=0; i < handle->post_pipe_id_count[FX_CONTROL_IN_RIF]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]+CONTROL_IN_RIF_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_IN_RIF][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_RIF_INGRESS, acl_id_list, acl_id_count , &handle->control_in_rif_group_id);
	if(rc) {
	    FX_LOG(SX_LOG_ERROR,"ERROR in creating control_in_rif group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_in_rif was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = rif_bind(handle,handle->control_in_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc == SX_STATUS_RESOURCE_IN_USE) {
	    FX_LOG(SX_LOG_INFO, "Rebinding interface (was it already bound by the NOS?)\n");
	    rc = SX_STATUS_SUCCESS;
	}
    control_in_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * MAX_RIFS);
	memcpy(control_in_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_in_rif_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_in_rif(fx_handle_t handle){
    if (control_in_rif_bind_list == 0) return 0;
	sx_status_t rc1 = rif_bind(handle, handle->control_in_rif_group_id,(boolean_t) false, control_in_rif_bind_list,control_in_rif_bind_list_cnt);
	free(control_in_rif_bind_list);
	control_in_rif_bind_list = NULL;
	control_in_rif_bind_list_cnt = 0;
	if (rc1) {
        FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_in_rif group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_RIF_INGRESS , &handle->control_in_rif_group_id);
	if (rc2) {
        FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_in_rif group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	if (delete_control_in_rif_table_bitmap_classification(handle)) {FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_in_rif, pipe table num: 0\n"); rc = SX_STATUS_ERROR;}
	if (delete_control_in_rif_table_bitmap_router(handle)) {FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_in_rif, pipe table num: 1\n"); rc = SX_STATUS_ERROR;}
	for (uint32_t i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_in_rif was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_in_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = rif_bind(handle, handle->control_in_rif_group_id,(boolean_t) false, control_in_rif_bind_list,control_in_rif_bind_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_in_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_in_rif_bind_list);
	control_in_rif_bind_list = NULL;
	control_in_rif_bind_list_cnt = 0;
	rc = rif_bind(handle,handle->control_in_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in binding control_in_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
    control_in_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * MAX_RIFS);
	memcpy(control_in_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_in_rif_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_OUT_RIF -----------------------------------
// pipe: control_out_rif
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_RIF_EGRESS
// type rif/port : rif
// auto tables iteration over:
// table name: control_out_rif_table_meta_tunnel ,  index : 0
// if_list type: pptype
// fx pipe enum: FX_CONTROL_OUT_RIF

static rif_handle_type *control_out_rif_bind_list = NULL;
static uint32_t control_out_rif_bind_list_cnt = 0;

sx_status_t create_pipe_control_out_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	if (create_control_out_rif_table_meta_tunnel(handle, handle->control_out_rif_id_list,0)){FX_LOG(SX_LOG_ERROR,"ERROR in creating control_out_rif, pipe table: control_out_rif_table_meta_tunnel\n"); return SX_STATUS_ERROR;}
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF] + CONTROL_OUT_RIF_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_OUT_RIF];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (uint32_t i=0; i < handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_OUT_RIF][i];
	for (uint32_t i=0; i < CONTROL_OUT_RIF_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]] = handle->control_out_rif_id_list[i];
	for (uint32_t i=0; i < handle->post_pipe_id_count[FX_CONTROL_OUT_RIF]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]+CONTROL_OUT_RIF_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_OUT_RIF][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_RIF_EGRESS, acl_id_list, acl_id_count , &handle->control_out_rif_group_id);
	if(rc) {
	    FX_LOG(SX_LOG_ERROR,"ERROR in creating control_out_rif group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_out_rif was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = rif_bind(handle,handle->control_out_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc == SX_STATUS_RESOURCE_IN_USE) {
	    FX_LOG(SX_LOG_INFO, "Rebinding interface (was it already bound by the NOS?)\n");
	    rc = SX_STATUS_SUCCESS;
	}
    control_out_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * MAX_RIFS);
	memcpy(control_out_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_out_rif_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_out_rif(fx_handle_t handle){
    if (control_out_rif_bind_list == 0) return 0;
	sx_status_t rc1 = rif_bind(handle, handle->control_out_rif_group_id,(boolean_t) false, control_out_rif_bind_list,control_out_rif_bind_list_cnt);
	free(control_out_rif_bind_list);
	control_out_rif_bind_list = NULL;
	control_out_rif_bind_list_cnt = 0;
	if (rc1) {
        FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_out_rif group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_RIF_EGRESS , &handle->control_out_rif_group_id);
	if (rc2) {
        FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_out_rif group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	if (delete_control_out_rif_table_meta_tunnel(handle)) {FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_out_rif, pipe table num: 0\n"); rc = SX_STATUS_ERROR;}
	for (uint32_t i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_out_rif was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_out_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = rif_bind(handle, handle->control_out_rif_group_id,(boolean_t) false, control_out_rif_bind_list,control_out_rif_bind_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_out_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_out_rif_bind_list);
	control_out_rif_bind_list = NULL;
	control_out_rif_bind_list_cnt = 0;
	rc = rif_bind(handle,handle->control_out_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in binding control_out_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
    control_out_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * MAX_RIFS);
	memcpy(control_out_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_out_rif_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_OUT_PORT -----------------------------------
// pipe: control_out_port
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_EGRESS
// type rif/port : port
// auto tables iteration over:
// if_list type: pptype
// fx pipe enum: FX_CONTROL_OUT_PORT

static port_handle_type *control_out_port_bind_list = NULL;
static uint32_t control_out_port_bind_list_cnt = 0;

sx_status_t create_pipe_control_out_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT] + CONTROL_OUT_PORT_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_OUT_PORT];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (uint32_t i=0; i < handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_OUT_PORT][i];
    for (uint32_t i=0; (int32_t)i < CONTROL_OUT_PORT_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]] = handle->control_out_port_id_list[i];
	for (uint32_t i=0; i < handle->post_pipe_id_count[FX_CONTROL_OUT_PORT]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]+CONTROL_OUT_PORT_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_OUT_PORT][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_EGRESS, acl_id_list, acl_id_count , &handle->control_out_port_group_id);
	if(rc) {
	    FX_LOG(SX_LOG_ERROR,"ERROR in creating control_out_port group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_out_port was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = port_bind(handle,handle->control_out_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc == SX_STATUS_RESOURCE_IN_USE) {
	    FX_LOG(SX_LOG_INFO, "Rebinding interface (was it already bound by the NOS?)\n");
	    rc = SX_STATUS_SUCCESS;
	}
	control_out_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_out_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_out_port_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_out_port(fx_handle_t handle){
    if (control_out_port_bind_list == 0) return 0;
	sx_status_t rc1 = port_bind(handle, handle->control_out_port_group_id,(boolean_t) false, control_out_port_bind_list,control_out_port_bind_list_cnt);
	free(control_out_port_bind_list);
	control_out_port_bind_list = NULL;
	control_out_port_bind_list_cnt = 0;
	if (rc1) {
        FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_out_port group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_EGRESS , &handle->control_out_port_group_id);
	if (rc2) {
        FX_LOG(SX_LOG_ERROR,"ERROR in deleting control_out_port group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	for (uint32_t i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	FX_LOG(SX_LOG_INFO, "Pipe control_out_port was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_out_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = port_bind(handle, handle->control_out_port_group_id,(boolean_t) false, control_out_port_bind_list,control_out_port_bind_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in unbinding control_out_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_out_port_bind_list);
	control_out_port_bind_list = NULL;
	control_out_port_bind_list_cnt = 0;
	rc = port_bind(handle,handle->control_out_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		FX_LOG(SX_LOG_ERROR,"ERROR in binding control_out_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_out_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_out_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_out_port_bind_list_cnt = if_list_cnt;

	return rc;
}

/* ---------------------------------- */
/* START of fx_base_entries Template  */
/* ---------------------------------- */
// TODO - replace general_template with jinja2

typedef sx_status_t fx_table_x_const_entry_set(fx_handle_t handle, struct acl_table *table);
fx_table_x_const_entry_set add_const_table_entries_control_in_rif_table_bitmap_classification;fx_table_x_const_entry_set add_const_table_entries_control_in_rif_table_bitmap_router;fx_table_x_const_entry_set add_const_table_entries_control_out_rif_table_meta_tunnel;
fx_table_x_const_entry_set * fx_table_x_const_entry_set_fn[3] = {
add_const_table_entries_control_in_rif_table_bitmap_classification,add_const_table_entries_control_in_rif_table_bitmap_router,add_const_table_entries_control_out_rif_table_meta_tunnel,
};

sx_status_t fx_table_entry_const_set(fx_handle_t handle, struct acl_table *table) {
    int table_index;
    sx_status_t rc = SX_STATUS_SUCCESS;
    fx_table_id_t table_id = table->table_id;
    rc = get_table_index_from_id (handle, table_id, &table_index);
    if (rc) return rc;
    table = &handle->acl_tables[table_index];
    rc = ( (*fx_table_x_const_entry_set_fn[table_index])(handle, table));
    if (rc) return rc;
    return rc;
}

/* ---------- */
sx_status_t add_const_table_entries_control_in_rif_table_bitmap_classification(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        status = SX_STATUS_PARAM_ERROR;
        goto out;
    }

    sx_acl_rule_offset_t     table_bitmap_classification_priority = table->const_entry_offset;
    uint32_t                 entry_count = 0;
    fx_key_list_t            table_bitmap_classification_key_list;
    fx_param_list_t          table_bitmap_classification_param_list;
    (void) table_bitmap_classification_key_list;
    (void) table_bitmap_classification_param_list;
    // TODO - error if const entries + default > table size
    table->const_entry_offset = table_bitmap_classification_priority;
    if (entry_count == 0) {
        FX_LOG(SX_LOG_WARNING, "[%s] Table table_bitmap_classification has no const entries\n", table->table_name);
    } else {
        FX_LOG(SX_LOG_WARNING, "[%s] Added table_bitmap_classification %u entries with id %x\n", table->table_name, entry_count, table->const_entry_offset);
    }
out:
    return status;
}

sx_status_t remove_const_table_entries_control_in_rif_table_bitmap_classification_entry(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status = SX_STATUS_SUCCESS;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        return SX_STATUS_PARAM_ERROR;
    }
        
    sx_acl_rule_offset_t off;
    for (off = 0; off < table->const_entry_offset; off++) {
        status = remove_table_entry_control_in_rif_table_bitmap_classification(handle, off);
    }
    table->const_entry_offset = 0;
    
    return status;
}
/* ---------- */
sx_status_t add_const_table_entries_control_in_rif_table_bitmap_router(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        status = SX_STATUS_PARAM_ERROR;
        goto out;
    }

    sx_acl_rule_offset_t     table_bitmap_router_priority = table->const_entry_offset;
    uint32_t                 entry_count = 0;
    fx_key_list_t            table_bitmap_router_key_list;
    fx_param_list_t          table_bitmap_router_param_list;
    (void) table_bitmap_router_key_list;
    (void) table_bitmap_router_param_list;
    // TODO - error if const entries + default > table size
    table->const_entry_offset = table_bitmap_router_priority;
    if (entry_count == 0) {
        FX_LOG(SX_LOG_WARNING, "[%s] Table table_bitmap_router has no const entries\n", table->table_name);
    } else {
        FX_LOG(SX_LOG_WARNING, "[%s] Added table_bitmap_router %u entries with id %x\n", table->table_name, entry_count, table->const_entry_offset);
    }
out:
    return status;
}

sx_status_t remove_const_table_entries_control_in_rif_table_bitmap_router_entry(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status = SX_STATUS_SUCCESS;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        return SX_STATUS_PARAM_ERROR;
    }
        
    sx_acl_rule_offset_t off;
    for (off = 0; off < table->const_entry_offset; off++) {
        status = remove_table_entry_control_in_rif_table_bitmap_router(handle, off);
    }
    table->const_entry_offset = 0;
    
    return status;
}
/* ---------- */
sx_status_t add_const_table_entries_control_out_rif_table_meta_tunnel(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status = SX_STATUS_SUCCESS;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        status = SX_STATUS_PARAM_ERROR;
        goto out;
    }

    sx_acl_rule_offset_t     table_meta_tunnel_priority = table->const_entry_offset;
    uint32_t                 entry_count = 0;
    fx_key_list_t            table_meta_tunnel_key_list;
    fx_param_list_t          table_meta_tunnel_param_list;
    (void) table_meta_tunnel_key_list;
    (void) table_meta_tunnel_param_list;
    // TODO - error if const entries + default > table size
    table->const_entry_offset = table_meta_tunnel_priority;
    if (entry_count == 0) {
        FX_LOG(SX_LOG_WARNING, "[%s] Table table_meta_tunnel has no const entries\n", table->table_name);
    } else {
        FX_LOG(SX_LOG_WARNING, "[%s] Added table_meta_tunnel %u entries with id %x\n", table->table_name, entry_count, table->const_entry_offset);
    }
out:
    return status;
}

sx_status_t remove_const_table_entries_control_out_rif_table_meta_tunnel_entry(fx_handle_t handle, struct acl_table *table)
{
    sx_status_t              status = SX_STATUS_SUCCESS;
    if (NULL == table) {
        FX_LOG(SX_LOG_ERROR, "NULL ACL table ptr\n");
        return SX_STATUS_PARAM_ERROR;
    }
        
    sx_acl_rule_offset_t off;
    for (off = 0; off < table->const_entry_offset; off++) {
        status = remove_table_entry_control_out_rif_table_meta_tunnel(handle, off);
    }
    table->const_entry_offset = 0;
    
    return status;
}






/* ---------------------------------- */
/* START of default_handle Template   */
/* ---------------------------------- */

static fx_handle_t fx_default_handle = NULL;
static bool        fx_default_initialized = false;

sx_status_t fx_default_handle_get(fx_handle_t **handle, const sx_api_handle_t *sx_handle, int do_init) {
    sx_status_t           sx_status;
    sx_port_log_id_t      port_list[PORT_NUM];
    sx_router_interface_t rif_list[RIF_NUM];
    uint32_t              num_of_ports = 0;
    uint32_t              num_of_rifs = 0;

    if (fx_default_initialized || !do_init)
    {
        *handle = &fx_default_handle;
        sx_status = SX_STATUS_SUCCESS;
        goto out;
    }

    fx_init(&fx_default_handle, sx_handle);
    fx_extern_init(fx_default_handle);

    sx_status = fx_get_bindable_port_list(fx_default_handle, port_list, &num_of_ports);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable port list size\n");
        goto out;
    }

    sx_status = fx_get_bindable_port_list(fx_default_handle, port_list, &num_of_ports);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable port list\n");
        goto out;
    }

    sx_status = fx_get_bindable_rif_list(fx_default_handle, rif_list, &num_of_rifs);
    if (sx_status)
    {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable rif list\n");
        goto out;
    }

    sx_status = fx_pipe_create(fx_default_handle, FX_CONTROL_OUT_RIF, (void *)rif_list, num_of_rifs);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Error - sx_status:%d\n", sx_status);
        goto out;
    }
    fx_default_initialized = true;
    *handle = &fx_default_handle;

out:
    return sx_status;
}

sx_status_t fx_default_handle_free() {
    sx_status_t  sx_status;
    sx_port_log_id_t port_list[PORT_NUM];
    sx_router_interface_t rif_list[RIF_NUM];
    uint32_t num_of_ports = 0;
    uint32_t num_of_rifs = 0;

    if (!fx_default_initialized)
    {
        sx_status = SX_STATUS_SUCCESS;
        goto out;
    }

    fx_default_initialized = false;

    sx_status = fx_get_bindable_port_list(fx_default_handle, port_list, &num_of_ports);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable port list size\n");
        goto out;
    }

    sx_status = fx_get_bindable_port_list(fx_default_handle, port_list, &num_of_ports);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable port list\n");
        goto out;
    }

    sx_status = fx_get_bindable_rif_list(fx_default_handle, rif_list, &num_of_rifs);
    if (sx_status)
    {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable rif list size\n");
        goto out;
    }

    sx_status = fx_get_bindable_rif_list(fx_default_handle, rif_list, &num_of_rifs);
    if (sx_status)
    {
        FX_LOG(SX_LOG_ERROR, "Failed to get bindable rif list\n");
        goto out;
    }

    sx_status = fx_pipe_destroy(fx_default_handle, FX_CONTROL_OUT_RIF, (void *)rif_list, num_of_rifs);
    if (sx_status) {
        FX_LOG(SX_LOG_ERROR, "Error - sx_status:%d\n", sx_status);
        return sx_status;
    }
    fx_extern_deinit(fx_default_handle);
    fx_deinit(fx_default_handle);
    fx_default_handle = NULL;

out:
    return sx_status;
}


sx_status_t binding_update_pipe_control_in_rif(fx_handle_t handle, void *iface, bool is_add) {
    if (NULL == iface) return SX_STATUS_ERROR;

    int rif_idx = -1;
    rif_handle_type rif = *(rif_handle_type*)iface;
    for (uint32_t i = 0; i < control_in_rif_bind_list_cnt; i++) {
        if (control_in_rif_bind_list[i] == rif) {
            rif_idx = i;
            break;
        }
    }

    if (is_add) {
        if (rif_idx != -1) {
            FX_LOG(SX_LOG_ERROR, "Failed to add rif %d to fx control_in_rif_bind_list - rif is already in the list\n", rif);
            return SX_STATUS_ERROR;
        }

        if (control_in_rif_bind_list_cnt == MAX_RIFS) {
            FX_LOG(SX_LOG_ERROR, "Failed to add rif %d to fx control_in_rif_bind_list - rif list is full\n", rif);
            return SX_STATUS_ERROR;
        }

        control_in_rif_bind_list[control_in_rif_bind_list_cnt] = rif;
        control_in_rif_bind_list_cnt++;
    } else {
        if (rif_idx == -1) {
            FX_LOG(SX_LOG_ERROR, "Failed to del rif %d to fx control_in_rif_bind_list - rif is not in the list\n", rif);
            return SX_STATUS_ERROR;
        }

        control_in_rif_bind_list[rif_idx] = control_in_rif_bind_list[control_in_rif_bind_list_cnt - 1];
        control_in_rif_bind_list_cnt--;
    }

    sx_status_t rc = rif_bind(handle, handle->control_in_rif_group_id, is_add, iface, 1);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "ERROR in bind update control_in_rif group: %s\n", SX_STATUS_MSG(rc));
        return rc;
    }

    return SX_STATUS_SUCCESS;
}

sx_status_t binding_update_pipe_control_out_rif(fx_handle_t handle, void *iface, bool is_add) {
    if (NULL == iface) return SX_STATUS_ERROR;

    int rif_idx = -1;
    rif_handle_type rif = *(rif_handle_type*)iface;
    for (uint32_t i = 0; i < control_out_rif_bind_list_cnt; i++) {
        if (control_out_rif_bind_list[i] == rif) {
            rif_idx = i;
            break;
        }
    }

    if (is_add) {
        if (rif_idx != -1) {
            FX_LOG(SX_LOG_ERROR, "Failed to add rif %d to fx control_out_rif_bind_list - rif is already in the list\n", rif);
            return SX_STATUS_ERROR;
        }

        if (control_out_rif_bind_list_cnt == MAX_RIFS) {
            FX_LOG(SX_LOG_ERROR, "Failed to add rif %d to fx control_out_rif_bind_list - rif list is full\n", rif);
            return SX_STATUS_ERROR;
        }

        control_out_rif_bind_list[control_out_rif_bind_list_cnt] = rif;
        control_out_rif_bind_list_cnt++;
    } else {
        if (rif_idx == -1) {
            FX_LOG(SX_LOG_ERROR, "Failed to del rif %d to fx control_out_rif_bind_list - rif is not in the list\n", rif);
            return SX_STATUS_ERROR;
        }

        control_out_rif_bind_list[rif_idx] = control_out_rif_bind_list[control_out_rif_bind_list_cnt - 1];
        control_out_rif_bind_list_cnt--;
    }

    sx_status_t rc = rif_bind(handle, handle->control_out_rif_group_id, is_add, iface, 1);
    if (rc) {
        FX_LOG(SX_LOG_ERROR, "ERROR in bind update for control_out_rif group: %s\n", SX_STATUS_MSG(rc));
        return rc;
    }

    return SX_STATUS_SUCCESS;
}
