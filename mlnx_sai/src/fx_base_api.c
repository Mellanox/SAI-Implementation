/* libfx_base autogenerated by P4 Compiler v1.0 */
/* From bmtor on January 21, 2019 02:42PM */

/* gcc acl.c -g -std=gnu99 -Wall -lsxnet -lsxapi -lsxcomp -lsxlog -oacl*/
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

/* flextrum */
#include <fx_base_api.h>
#include <flextrum_types.h> // For platform specific defines
#include <fx_base_range_match.h>
#include <mlnx_flex_bitmap.h>

/* Mellanox SDK */
#include <sx/sdk/sx_api.h>
#include <sx/sdk/sx_api_acl.h>
#include <sx/sdk/sx_api_bridge.h>
#include <sx/sdk/sx_api_init.h>
#include <sx/sdk/sx_api_fdb.h>
#include <sx/sdk/sx_api_flex_acl.h>
#include <sx/sdk/sx_api_flow_counter.h>
#include <sx/sdk/sx_api_host_ifc.h>
#include <sx/sdk/sx_api_port.h>
#include <sx/sdk/sx_api_router.h>
#include <sx/sdk/sx_api_tunnel.h>
#include <sx/sdk/sx_api_vlan.h>
#include <sx/sdk/sx_lib_flex_acl.h>
#include <sx/sdk/sx_lib_host_ifc.h>
#include <sx/sdk/sx_port.h>
#include <sx/sdk/sx_port_id.h>
#include <sx/sdk/sx_trap_id.h>

#include <arpa/inet.h>
#include <syslog.h>

#include <complib/sx_log.h>

/////////////////////////////
// defines
/////////////////////////////
typedef u_int8_t uint8_t;

// TODO - fix this per pipeline macro in the general template, as it depends
// upon the syntax used in the p4 compiler
#define CONTROL_IN_PORT_TABLE_NUM 0
#define CONTROL_IN_RIF_TABLE_NUM 2
#define CONTROL_OUT_RIF_TABLE_NUM 0
#define CONTROL_OUT_PORT_TABLE_NUM 0

#define MAX_LOG_PORTS 32
#define MAX_LOG_PORT_INDEX 64
const uint32_t ENDIAN_INT = 1;
#define is_bigendian() ( (*(char*)&ENDIAN_INT ) == 0 )

// syslog plus console output, formatted printf style
#define SYSLOGF(L, FMT, ...) \
{  \
   if (L == LOG_ERR) syslog(L, "[FX_API] " FMT, __VA_ARGS__); \
   printf("[%s] %s:%i: " FMT, __FILE__, __func__,__LINE__, __VA_ARGS__); \
}

typedef sx_port_log_id_t port_handle_type;
typedef sx_router_interface_t rif_handle_type;

typedef struct acl_table {
    fx_table_id_t     table_id;
    sx_acl_size_t           table_size;
    sx_acl_direction_t      pipe_line;
    sx_acl_region_id_t      region_id;
    sx_acl_id_t             acl_id;
    sx_acl_id_t             group_id;
    sx_acl_key_type_t       key_handle;
    sx_acl_key_t            *key_list;
    uint32_t                key_count; 
    sx_flow_counter_id_t*   rule_counters;
    fx_bitmap_t             valid_offsets;
    sx_acl_rule_offset_t    default_entry_offset;
    char                    table_name[MAX_TABLE_NAME_LEN];
    fx_range_table_t*       range_table; /* Used for Range match type and future extensions */
}acl_table;

typedef struct fx_custom_params {
    boolean_t is_cb;              /* true - use this custum byte set */
    uint32_t cb_offset;           /* extraction offset from start of header */
    uint32_t cb_size;             /* extraction size in bytes to extract */
    uint32_t field_offset;        /* offset of field from start of header */
    uint32_t field_size;          /* size in bytes of field */
    uint32_t cb_key_index_start;  /* starting index in the acl key list */
    uint32_t cb_key_list_size;    /* number of CB list entries */
    sx_acl_custom_bytes_set_attributes_t  attr;
}fx_custom_params;

//fx_handle_t is just a pointer to fx_handle
typedef struct fx_handle {
    sx_api_handle_t      sdk_handle;
    sx_port_log_id_t     log_port_list[MAX_LOG_PORTS+1];
    uint32_t             label_port_list[MAX_LOG_PORTS+1];
    uint32_t             index_port_list[MAX_LOG_PORT_INDEX+1];
    uint32_t             port_mode[MAX_LOG_PORTS+1];
    uint32_t             port_cnt;
    struct acl_table     acl_tables[2];
    uint8_t              num_sdk_actions_for_action_id[7];

    sx_acl_id_t          control_in_port_group_id;
    sx_acl_id_t          control_in_port_id_list[CONTROL_IN_PORT_TABLE_NUM];
    sx_acl_id_t          control_in_rif_group_id;
    sx_acl_id_t          control_in_rif_id_list[CONTROL_IN_RIF_TABLE_NUM];
    sx_acl_id_t          control_out_rif_group_id;
    sx_acl_id_t          control_out_rif_id_list[CONTROL_OUT_RIF_TABLE_NUM];
    sx_acl_id_t          control_out_port_group_id;
    sx_acl_id_t          control_out_port_id_list[CONTROL_OUT_PORT_TABLE_NUM];

    sx_acl_id_t*         pre_pipe_id_list[FX_PIPE_TYPE_MAX];           /* application supplied flex acl */
    uint32_t             pre_pipe_id_count[FX_PIPE_TYPE_MAX];
    sx_acl_id_t*         post_pipe_id_list[FX_PIPE_TYPE_MAX];          /* application supplied flex acl */
    uint32_t             post_pipe_id_count[FX_PIPE_TYPE_MAX];

}fx_handle;

/* per table function implemntatons declerations */
typedef sx_status_t fx_table_x_entry_add (fx_handle_t handle,
        fx_action_id_t action_id,
        fx_key_list_t keys,
        fx_param_list_t params,
        sx_acl_rule_offset_t* offset_ptr);
// per table remove needed only for range tables
typedef sx_status_t fx_table_x_entry_remove (fx_handle_t handle,
        uint8_t offset);

// typedef sx_status_t (*fx_table_x_entry_remove)(fx_handle_t handle, uint32_t table_id ,sx_acl_rule_offset_t offset);

typedef sx_status_t fx_create_pipe_x(fx_handle_t handle,
        void *if_list,
        uint32_t if_list_cnt);

typedef sx_status_t fx_delete_pipe_x(fx_handle_t handle);

typedef sx_status_t fx_rebind_pipe_x(fx_handle_t handle,
        void *if_list,
        uint32_t if_list_cnt);

typedef sx_status_t fx_table_x_default_entry_set(fx_handle_t handle,
        struct acl_table *table,
        fx_param_list_t params,
        int action_id);

typedef void fx_table_x_deinit_keys(fx_key_list_t keys[], size_t rule_cnt);
typedef void fx_table_x_init_keys(fx_key_list_t keys[], size_t rule_cnt);

/* Functions mapping */
fx_create_pipe_x create_pipe_control_in_port, create_pipe_control_in_rif,create_pipe_control_out_rif,create_pipe_control_out_port; // TODO - make python output.
fx_delete_pipe_x delete_pipe_control_in_port, delete_pipe_control_in_rif,delete_pipe_control_out_rif,delete_pipe_control_out_port; // TODO - make python output.
fx_rebind_pipe_x rebind_pipe_control_in_port, rebind_pipe_control_in_rif,rebind_pipe_control_out_rif,rebind_pipe_control_out_port; // TODO - make python output.
fx_create_pipe_x *fx_create_pipe_x_fn[4] = {create_pipe_control_in_port,create_pipe_control_in_rif,create_pipe_control_out_rif,create_pipe_control_out_port};
fx_delete_pipe_x *fx_delete_pipe_x_fn[4] = {delete_pipe_control_in_port,delete_pipe_control_in_rif,delete_pipe_control_out_rif,delete_pipe_control_out_port};
fx_rebind_pipe_x *fx_rebind_pipe_x_fn[4] = {rebind_pipe_control_in_port,rebind_pipe_control_in_rif,rebind_pipe_control_out_rif,rebind_pipe_control_out_port};
fx_table_x_entry_add  add_table_entry_control_in_rif_table_bitmap_classification, add_table_entry_control_in_rif_table_bitmap_router;
fx_table_x_entry_add * fx_table_x_entry_add_fn[2] = {add_table_entry_control_in_rif_table_bitmap_classification, add_table_entry_control_in_rif_table_bitmap_router};
fx_table_x_default_entry_set  fx_control_in_rif_table_bitmap_classification_default_entry_set, fx_control_in_rif_table_bitmap_router_default_entry_set;
fx_table_x_default_entry_set * fx_table_x_default_entry_set_fn[2] = {fx_control_in_rif_table_bitmap_classification_default_entry_set, fx_control_in_rif_table_bitmap_router_default_entry_set};
fx_table_x_init_keys  fx_init_key_list_control_in_rif_table_bitmap_classification, fx_init_key_list_control_in_rif_table_bitmap_router;
fx_table_x_init_keys * fx_table_x_init_keys_fn[2] = {fx_init_key_list_control_in_rif_table_bitmap_classification, fx_init_key_list_control_in_rif_table_bitmap_router};
fx_table_x_deinit_keys  fx_deinit_key_list_control_in_rif_table_bitmap_classification, fx_deinit_key_list_control_in_rif_table_bitmap_router;
fx_table_x_deinit_keys * fx_table_x_deinit_keys_fn[2] = {fx_deinit_key_list_control_in_rif_table_bitmap_classification, fx_deinit_key_list_control_in_rif_table_bitmap_router};
/////////////////////////////
// General functions
/////////////////////////////
sx_status_t init_port_mapping(fx_handle_t handle);


/* Open spectrum SDK */
sx_status_t
fx_init(fx_handle_t *handle)
{
    *handle = malloc(sizeof (fx_handle));
    if(*handle==NULL){ return SX_STATUS_NO_MEMORY;}
    memset(*handle, 0, sizeof (fx_handle));

    printf("FLEX-BASE: init_flex_api Opening SDK...");
    sx_status_t rc = sx_api_open(NULL, &(*handle)->sdk_handle);
    if (rc) { 
      SYSLOGF(LOG_ERR, "ERROR: SDK API sx_api_open failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
    }
    return init_port_mapping(*handle);
}
/* Close spectrum SDK */
sx_status_t fx_deinit(fx_handle_t handle) {
    printf("FLEX-BASE: deinit_flex_api Closing SDK...\n");
    sx_status_t rc = sx_api_close(&handle->sdk_handle);
    memset(handle, 0, sizeof(fx_handle));
    free(handle);
    return rc;
}

sx_status_t fx_extern_init(fx_handle_t handle) {
     return SX_STATUS_SUCCESS;
}

sx_status_t fx_extern_deinit(fx_handle_t handle) {
     return SX_STATUS_SUCCESS;
}

sx_status_t fx_sdk_handle_get(fx_handle_t handle, sx_api_handle_t *sdk_handle) {
    sx_status_t rc;
    if (handle != NULL && sdk_handle != NULL && handle->sdk_handle != SX_API_INVALID_HANDLE) {
        *sdk_handle = handle->sdk_handle;
        rc = SX_STATUS_SUCCESS;
    }
    else {
        rc = SX_STATUS_PARAM_ERROR;
    }
    return rc;
}

/* Create key handle */
sx_status_t 
create_acl_p4_key(fx_handle_t handle, struct acl_table * acl_table, struct fx_custom_params *custom)
{
    sx_status_t rc;
    if (custom && custom->is_cb) {
        /* P4C statically decides if the ACL key needs custom bytes */
        rc = sx_api_acl_custom_bytes_set(handle->sdk_handle,SX_ACCESS_CMD_CREATE,
                                                &custom->attr,
                                                &acl_table->key_list[custom->cb_key_index_start],
                                                &custom->cb_key_list_size);
        if (rc) {
            // DEBUG
            printf("%s: sx_api_acl_custom_bytes_set, acl keys: ", rc ? "Failure" : "Success");
            for (int i=custom->cb_key_index_start; i < custom->cb_key_index_start + custom->cb_key_list_size; i++) {
                printf ("%d, ", acl_table->key_list[i]);
            }
            printf ("\n");
            SYSLOGF(LOG_ERR, "ERROR: SDK API sx_api_acl_custom_bytes_set failed: [%s]\n", SX_STATUS_MSG(rc));
            return rc;
        }
    }

    rc = sx_api_acl_flex_key_set(
            handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_table->key_list,
            acl_table->key_count,
            &acl_table->key_handle);
    if (rc) {
        // TODO - syslog from SDK is SX_LOG_ERR("Failed calculating key blocks.\n") if
        // the acl key size is too large. This is hard to debug, need a compiler semantic check.
        if (acl_table->key_handle == 0) {
            SYSLOGF(LOG_ERR, "ERROR: Failed to set %i %s keys (hw limit exceeded)\n",
                    acl_table->key_count, acl_table->table_name);
        }
        // DEBUG
        printf("%s: sx_api_acl_flex_key_set: %s", rc ? "FAILURE" : "Success", acl_table->table_name);
        printf("handle 0x%x, %d keys: ", acl_table->key_handle, acl_table->key_count);
        printf ("key_list = ");
        for (int i=0; i < acl_table->key_count; i++) {
            printf ("%d, ", acl_table->key_list[i]);
        }
        printf("\n");
        SYSLOGF(LOG_ERR, "ERROR: SDK API sx_api_acl_flex_key_set failed: [%s]\n", SX_STATUS_MSG(rc));
    }

    return rc;
}

/* Create ACL region */
sx_status_t create_acl_table(fx_handle_t handle,struct acl_table * acl_table)
{
    sx_status_t rc = sx_api_acl_region_set(handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_table->key_handle,
            SX_ACL_ACTION_TYPE_BASIC,
            acl_table->table_size,
            &acl_table->region_id);
    if (rc) {
        printf("ERROR: SDK API sx_api_acl_region_set failed: [%s]\n", SX_STATUS_MSG(rc));
        return(rc);
    }
    else {
        printf("sx_api_acl_region_set to id %#x\n", acl_table->region_id);
    }

    sx_acl_type_t acl_type = SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC;
    sx_acl_region_group_t acl_region_group = {
            .acl_type = acl_type,
            .regions = {
                    .acl_packet_agnostic = {
                            .region = acl_table->region_id,
                    }
            }
    };

    rc = sx_api_acl_set(handle->sdk_handle,
            SX_ACCESS_CMD_CREATE,
            acl_type,
            acl_table->pipe_line,//SX_ACL_DIRECTION_INGRESS,
            &acl_region_group,
            &acl_table->acl_id);
    if (rc) {
        printf("Error %d: failed to create acl: [%s]\n", rc, SX_STATUS_MSG(rc));
        return rc;
    }
    // TODO remove counters after verification
    acl_table->rule_counters = (sx_flow_counter_id_t*) malloc(sizeof(sx_flow_counter_id_t)*acl_table->table_size);

    alloc_bitmap(&acl_table->valid_offsets, acl_table->table_size);

    acl_table->default_entry_offset = acl_table->table_size - 1;
    return SX_STATUS_SUCCESS;
}

/* Create and set ACL Group */
sx_status_t assign_tables_to_group(fx_handle_t handle,sx_acl_direction_t direction, sx_acl_id_t* pipe_id_list, uint32_t pipe_table_num , sx_acl_id_t* pipe_group_id){
  sx_status_t rc = sx_api_acl_group_set(handle->sdk_handle,
                                        SX_ACCESS_CMD_CREATE,
                                        direction,
                                        pipe_id_list, // ignored upon create
                                        0,  // ignored upon create
                                        pipe_group_id);
  if (rc != SX_STATUS_SUCCESS) {
      printf("ERROR: SDK API sx_api_acl_group_set failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  printf("SDK API: created pipe Group Id: %#x \n", *pipe_group_id);
  rc = sx_api_acl_group_set(handle->sdk_handle,
                                   SX_ACCESS_CMD_SET,
                                   direction,
                                   pipe_id_list,
                                   pipe_table_num,
                                   pipe_group_id);
  if (rc != SX_STATUS_SUCCESS) {
      printf("ERROR: SDK API sx_api_acl_group_set failed: [%s]\n", SX_STATUS_MSG(rc));
      return rc;
  }
  printf("SDK API: pipe tables added to pipe Group Id: %#x \n", *pipe_group_id);
  return SX_STATUS_SUCCESS;
}
// ----------------- port/ rif bindings -----------------------------

sx_status_t
fx_get_bindable_port_list(fx_handle_t handle, sx_port_log_id_t *if_list, uint32_t *if_list_cnt)
{
  sx_status_t rc;
  if (*if_list_cnt == 0) {
    rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, NULL, if_list_cnt);
    if (rc)
    {
      printf("ERROR: SDK API sx_api_port_device_get failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    return rc;
  }

  *if_list_cnt = 0;
  sx_port_attributes_t port_list[PORT_NUM];
  uint32_t num_of_ports = PORT_NUM;
  rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, port_list, &num_of_ports);
  if (rc)
  {
    printf("ERROR: SDK API sx_api_port_device_get failed: [%s]\n", SX_STATUS_MSG(rc));
    return rc;
  }
  for (uint32_t i = 0; i < num_of_ports; i++)
  {
    if (port_list[i].port_mode == SX_PORT_MODE_EXTERNAL)
    {
      if_list[*if_list_cnt] = port_list[i].log_port;
      (*if_list_cnt)++;
    }
  }
  printf("Bindable ports:");
  for (uint32_t i = 0; i < *(if_list_cnt); i++)
  {
    printf(" 0x%x", if_list[i]);
  }
  printf(".\nfx_get_port_if_list success, number of exernal interfaces: %d\n", *if_list_cnt);
  return SX_STATUS_SUCCESS;
}

sx_status_t fx_get_bindable_rif_list(fx_handle_t handle, sx_router_interface_t *if_list, uint32_t *if_list_cnt)
{
  bool print_rifs = (*if_list_cnt != 0);
  sx_status_t rc = sx_api_router_interface_iter_get(handle->sdk_handle, SX_ACCESS_CMD_GET, 0, 0, if_list, if_list_cnt);
  if (rc != SX_STATUS_SUCCESS)
  {
    printf("ERROR: SDK API sx_api_router_interface_iter_get failed: [%s]\n", SX_STATUS_MSG(rc));
    return rc;
  }
  rc = sx_api_router_interface_iter_get(handle->sdk_handle, SX_ACCESS_CMD_GET_FIRST, 0, 0, if_list, if_list_cnt);
  if (rc != SX_STATUS_SUCCESS)
  {
    printf("ERROR: SDK API sx_api_router_interface_iter_get failed: [%s]\n", SX_STATUS_MSG(rc));
    return rc;
  }
  if (if_list_cnt == 0)
  {
    printf("WARNING: no RIF configured in switch.\n");
    return SX_STATUS_SUCCESS;
  }
  if (print_rifs) {
    printf("Bindable rifs:");
    for (uint32_t i = 0; i < *(if_list_cnt); i++)
    {
      printf(" 0x%x", if_list[i]);
    }
  }
  printf(".\nfx_get_rif_if_list success, number of rifs: %d\n", *if_list_cnt);
  return SX_STATUS_SUCCESS;
}

//binding: 
// port:  const sx_port_log_id_t log_port - uint32_t
// rif : sx_rif_id_t rif_id uint32_t

// bind+unbind selector
sx_status_t
port_bind(fx_handle_t handle, const sx_acl_id_t group_id,boolean_t bind, sx_port_log_id_t *if_list, uint32_t if_list_cnt)
{
  if ((if_list == NULL && if_list_cnt != 0) || handle == NULL) return SX_STATUS_PARAM_ERROR;
  sx_status_t worst_rc = SX_STATUS_SUCCESS;
  sx_access_cmd_t bind_cmd = bind ? SX_ACCESS_CMD_BIND : SX_ACCESS_CMD_UNBIND;
  for(uint32_t i=0;i<if_list_cnt;i++) {
    printf("0x%x, ",if_list[i]);
    sx_status_t rc = sx_api_acl_port_bind_set(handle->sdk_handle,
                                            bind_cmd,
                                            if_list[i],
                                            group_id);
    if (rc != SX_STATUS_SUCCESS) {
      printf("ERROR: SDK API sx_api_acl_port_bind_set failed: [%s]\n", SX_STATUS_MSG(rc));
      if (rc > worst_rc) worst_rc = rc;
    }
  }
  printf(".\n");
  return worst_rc;
}

sx_status_t 
rif_bind(fx_handle_t handle, const sx_acl_id_t group_id,boolean_t bind, sx_router_interface_t *if_list, uint32_t if_list_cnt){
  if ((if_list == NULL && if_list_cnt != 0) || handle == NULL) return SX_STATUS_PARAM_ERROR;
  sx_status_t worst_rc = SX_STATUS_SUCCESS;
  sx_status_t rc;
  sx_access_cmd_t bind_cmd = bind ? SX_ACCESS_CMD_BIND : SX_ACCESS_CMD_UNBIND;
  printf("%s P4 flex pipe to rif ids: ", bind ? "Binding" : "Unbinding");
  for(uint32_t i=0;i<if_list_cnt;i++) {
    printf("%x, ",if_list[i]);
    rc = sx_api_acl_rif_bind_set (handle->sdk_handle,
                                  bind_cmd,
                                  if_list[i],
                                  group_id 
    );
    if (rc != SX_STATUS_SUCCESS) {
        printf("ERROR: SDK API sx_api_acl_rif_bind_set failed: [%s]\n", SX_STATUS_MSG(rc));
        if (rc > worst_rc) worst_rc = rc;
    }
  }
  printf(".\n");
  return worst_rc;
}

//------------------- ACL handling ----------------------------

sx_status_t
delete_acl_group(fx_handle_t handle,sx_acl_direction_t direction, sx_acl_id_t* pipe_group_id){
    sx_status_t rc = sx_api_acl_group_set(handle->sdk_handle,
                                     SX_ACCESS_CMD_DESTROY,
                                     direction,
                                     NULL, // ignored
                                     0, // ignored
                                     pipe_group_id);
    if (rc != SX_STATUS_SUCCESS) {
        printf("ERROR: SDK API sx_api_group_delete failed: [%s]\n", SX_STATUS_MSG(rc));
    }
    else {
        printf("SDK API: group destroyed \n");
    }
    return rc;
}

int delete_acl(fx_handle_t handle,struct acl_table *acl_table)
{
  printf("delete P4 table\n");
  sx_status_t           rc1 = SX_STATUS_SUCCESS;
  sx_status_t           rc2 = SX_STATUS_SUCCESS;
  free_bitmap(acl_table->valid_offsets);
  acl_table->valid_offsets = 0;
  free(acl_table->rule_counters);
  acl_table->rule_counters = 0;
  sx_acl_region_group_t acl_region_group = {
              .acl_type = SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC,
              .regions = {
                  .acl_packet_agnostic = {
                      .region = acl_table->region_id,
                  }
              }
          };
  rc1=sx_api_acl_set(handle->sdk_handle,
              SX_ACCESS_CMD_DESTROY,
                  SX_ACL_TYPE_PACKET_TYPES_AGNOSTIC,
                  SX_ACL_DIRECTION_INGRESS,
                  &acl_region_group,
                  &acl_table->acl_id);
  if(rc1) {
    printf("ERROR %s: failed to delete P4 Table: %s \n",SX_STATUS_MSG(rc1), acl_table->table_name);
  }

  rc2=sx_api_acl_region_set(handle->sdk_handle,
       SX_ACCESS_CMD_DESTROY,
            acl_table->key_handle,
            SX_ACL_ACTION_TYPE_BASIC,
            acl_table->table_size,
            &acl_table->region_id);
  if(rc2) {
    printf("ERROR: failed to delete table region: [%s]  \n",SX_STATUS_MSG(rc2));
   }
   return rc1 ? rc1 : rc2;
}

int remove_table_entry(fx_handle_t handle, struct acl_table *acl_table, sx_acl_rule_offset_t offset) {
    sx_status_t rc1 = SX_STATUS_SUCCESS;
    rc1 = sx_api_acl_flex_rules_set(handle->sdk_handle, SX_ACCESS_CMD_DELETE, acl_table->region_id, &offset, NULL, 1);
    if (rc1) {
        printf("ERROR: failed to remove rule at offset %d: [%s]\n", offset, SX_STATUS_MSG(rc1));
    }
    sx_status_t rc2 = SX_STATUS_SUCCESS;
    if (0 != acl_table->rule_counters) {
        rc2 = sx_api_flow_counter_clear_set(handle->sdk_handle, acl_table->rule_counters[offset]);
    }
    if(rc2){
      printf("ERROR: failed to clear counter at offset %d, [%s]\n", offset, SX_STATUS_MSG(rc2));
    }
    if (0 != acl_table->valid_offsets) {
        reset_bitmap(acl_table->valid_offsets, offset);
    }
    return rc1 ? rc1 : rc2;
}

void delete_all_rules(fx_handle_t handle, struct acl_table *acl_table) {
    printf("Deleting all rules in table %s\n", acl_table->table_name);
    for (int i=0; i<acl_table->table_size; i++) {
        if (0 != acl_table->valid_offsets && get_bitmap(acl_table->valid_offsets, i) == 1) {
            remove_table_entry(handle, acl_table, i);
        }
    }
}

sx_status_t
delete_p4_key(fx_handle_t handle, struct acl_table *acl_table, struct fx_custom_params *custom)
{
  printf("delete P4 key\n");
  sx_status_t rc1 = sx_api_acl_flex_key_set(handle->sdk_handle,
               SX_ACCESS_CMD_DELETE,
               acl_table->key_list,
               acl_table->key_count,
               &acl_table->key_handle);
  if(rc1) {
    printf("ERROR: fail to Delete P4 Table key type. [%s]\n", SX_STATUS_MSG(rc1));
  }
  printf("delete CB\n");
  sx_status_t rc2 = SX_STATUS_SUCCESS;
  if (custom && custom->is_cb) {
      /* P4C statically decides if the ACL key needs custom bytes */
      rc2 = sx_api_acl_custom_bytes_set(handle->sdk_handle,SX_ACCESS_CMD_DESTROY,
                                              &custom->attr,
                                              &acl_table->key_list[custom->cb_key_index_start],
                                              &custom->cb_key_list_size);
      if (rc2){
        printf("ERROR: SDK API sx_api_acl_custom_bytes_set failed: [%s]\n", SX_STATUS_MSG(rc2));
      }
  }
  return rc1 ? rc1 : rc2;
}

/* Rule counters */
sx_status_t
alloc_rule_counters(fx_handle_t handle, struct acl_table *acl_table) {
  sx_status_t           rc = SX_STATUS_SUCCESS;
  printf("Allocating rule counters\n");
  for(int i=0;i<acl_table->table_size;i++)  {
    rc=sx_api_flow_counter_set(handle->sdk_handle,SX_ACCESS_CMD_CREATE,
      SX_FLOW_COUNTER_TYPE_PACKETS_AND_BYTES,&acl_table->rule_counters[i]);
    if(rc){
      printf("ERROR: failed to allocate rule flow counter %d, [%s]\n", i,SX_STATUS_MSG(rc));
      return rc;
    }
  }
  return SX_STATUS_SUCCESS;
}

void delete_rule_counters(fx_handle_t handle, struct acl_table *acl_table) {
  printf("delete table's rule counters\n");
  sx_status_t           rc = SX_STATUS_SUCCESS;
  printf("Deleting rule counters\n");
  for(int i=0;i<acl_table->table_size;i++)  {
    rc=sx_api_flow_counter_set(handle->sdk_handle,SX_ACCESS_CMD_DESTROY,
        SX_FLOW_COUNTER_TYPE_PACKETS_AND_BYTES,&acl_table->rule_counters[i]);
    if(rc) {
      printf("ERROR: fail to  delete flow counter %d, [%s]\n", i, SX_STATUS_MSG(rc));
      return ;
    }
  }
}

/* map between table_id and fx_handle table index*/
sx_status_t get_table_index_from_id (fx_handle_t handle, const fx_table_id_t table_id, int *table_index){
  for (int i=0; i<2; i++){
    if(handle->acl_tables[i].table_id == table_id){
      *table_index = i;
      return SX_STATUS_SUCCESS;
    }
  }
  SYSLOGF(LOG_ERR, "ERROR: Flex Table not initialized, ID: %i\n", table_id);
  return SX_STATUS_UNSUPPORTED;
}

sx_status_t get_sdk_action_num_from_id (const fx_action_id_t action_id, int *sdk_actions_count){
  switch (action_id) {
    /* assign number of primitives per user defined action */
		case CONTROL_IN_RIF_DROP_ID: /* 16778278 */
			*sdk_actions_count = 1;
			return SX_STATUS_SUCCESS;
		case CONTROL_IN_RIF_SET_METADATA_ID: /* 16786535 */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
		case CONTROL_IN_RIF_TO_CPU_ID: /* 16819019 */
			*sdk_actions_count = 1;
			return SX_STATUS_SUCCESS;
		case CONTROL_IN_RIF_TO_NEXTHOP_ID: /* 16825799 */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
		case NOACTION_ID: /* 16800567 */
			*sdk_actions_count = 0;
			return SX_STATUS_SUCCESS;
		case CONTROL_IN_RIF_TO_LOCAL_ID: /* 16841981 */
			*sdk_actions_count = 2;
			return SX_STATUS_SUCCESS;
      default:
        SYSLOGF(LOG_ERR, "ERROR: requested action id is not in the action list: %i\n", action_id);
        return (SX_STATUS_PARAM_ERROR);
  }
}

/* These functions read/clear rule counters*/ 
// TODO : need to check if counter was asgined to rule if action has hit_counters()
// TODO : 
sx_status_t fx_table_rule_counters_print_all(fx_handle_t handle, fx_table_id_t table_id){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;

  struct acl_table *table = &handle->acl_tables[table_index];
  sx_status_t rc_final = SX_STATUS_SUCCESS;
  sx_flow_counter_set_t  counter;
  sx_acl_rule_offset_t offsets[table->table_size];
  uint32_t rules_cnt = 0;
  sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, offsets, NULL, &rules_cnt);
  SYSLOGF(LOG_ERR, "marianp Table: %s. %d valid rules. rule counters: \n",table->table_name, rules_cnt);
  for(int i=0;i<table->table_size;i++){
    if (get_bitmap(table->valid_offsets, i) == 1) {
      rc=sx_api_flow_counter_get(handle->sdk_handle,SX_ACCESS_CMD_READ,table->rule_counters[i],&counter);
      if(rc){
          SYSLOGF(LOG_ERR, "ERROR: rule %d counter is N/A \n", i);
        rc_final = rc;
      } else{
        SYSLOGF(LOG_ERR, "marianp *rule %d; counter byte %" PRIu64 "; packets %" PRIu64 ";\n",i,counter.flow_counter_bytes,counter.flow_counter_packets);
      }
    }
  }
  printf("\n");
  return rc_final;
}



sx_status_t fx_table_rule_counters_clear_all(fx_handle_t handle, fx_table_id_t table_id){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  sx_status_t rc_final = SX_STATUS_SUCCESS;
  for(int i=0;i<table->table_size;i++){
      rc= sx_api_flow_counter_clear_set(handle->sdk_handle,table->rule_counters[i]);
      if(rc){
          SYSLOGF(LOG_ERR, "ERROR: rule %d counter is N/A \n", i);
        rc_final = rc;
      }
    }
  printf("Counters cleared\n");
  return rc_final;
}


sx_status_t fx_table_rule_counter_read(fx_handle_t handle, fx_table_id_t table_id, sx_acl_rule_offset_t offset, uint64_t *bytes, uint64_t *packets){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;

  struct acl_table *table = &handle->acl_tables[table_index];
  sx_flow_counter_set_t  counter;
  if (get_bitmap(table->valid_offsets, offset) == 0) {
    SYSLOGF(LOG_ERR, "ERROR [fx_table_rule_counters_read]: Got invalid offset %d. table_id %d \n", offset, table_id);
    return SX_STATUS_PARAM_ERROR;
  }
  rc=sx_api_flow_counter_get(handle->sdk_handle,SX_ACCESS_CMD_READ,table->rule_counters[offset],&counter);
  if(rc){
    SYSLOGF(LOG_ERR, "ERROR %d: rule counter is N/A \n", rc);
    return rc;
  } else{
    *bytes = counter.flow_counter_bytes;
    *packets = counter.flow_counter_packets;
  }
  return rc;
}

sx_status_t fx_table_rule_counter_clear(fx_handle_t handle, fx_table_id_t table_id, sx_acl_rule_offset_t offset){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  
  if (get_bitmap(table->valid_offsets, offset) == 0) {
    SYSLOGF(LOG_ERR, "ERROR [fx_table_rule_counter_clear]: Got invalid offset %d. table_id %d \n", offset, table_id);
    return SX_STATUS_PARAM_ERROR;
  }
  rc= sx_api_flow_counter_clear_set(handle->sdk_handle,table->rule_counters[offset]);
  if(rc){
    return rc;
  }
  return rc;
}


sx_status_t create_p4_table(fx_handle_t handle, struct acl_table *table, struct fx_custom_params *custom) {
  printf("FLEX-BASE: create_p4_table. creating key\n");
  sx_status_t rc = create_acl_p4_key(handle, table, custom);
  if (rc) {return rc;}
  printf("Success, creating table:\n" );
  rc = create_acl_table(handle, table);
  if (rc) {return rc;}
  rc = alloc_rule_counters(handle, table);
  if (rc) {return rc;}
  return SX_STATUS_SUCCESS;
}

sx_status_t delete_p4_table(fx_handle_t handle, struct acl_table *table, struct fx_custom_params *custom) {
    printf("FLEX-BASE: delete_p4_table\n");
    delete_all_rules(handle, table);
    delete_rule_counters(handle, table);
    sx_status_t rc = delete_acl(handle, table);
    delete_p4_key(handle, table, custom);
    if (rc) {
      return rc;
    }
    return SX_STATUS_SUCCESS;
}

/* private function to get offsets */
void get_exact_offset_internal(struct acl_table *table, sx_acl_rule_offset_t *offset_ptr) {
    for (int i=0; i<table->table_size; i++) {
        if (get_bitmap(table->valid_offsets, i) == 0) {
          *offset_ptr = i;
          return;
        }
    }
    printf("exact match table %s is full\n", table->table_name);
    return;
}

/* private function to set the acl, for all table types */
int add_acl_rule_internal(fx_handle_t handle, sx_flex_acl_flex_rule_t* rule, sx_acl_rule_offset_t* rule_offset, struct acl_table *table) {
    sx_status_t rc=sx_api_acl_flex_rules_set(handle->sdk_handle, SX_ACCESS_CMD_SET,  table->region_id, rule_offset, rule, 1);
  if(rc) {
      // DEBUG
    printf("offset %d\n", *rule_offset);
    printf("cb rule key : %d\n", rule->key_desc_list_p->key.custom_byte);
    printf("first rule key id : %d\n", rule->key_desc_list_p->key_id);
    printf("cb rule mask : %d\n", rule->key_desc_list_p->mask.custom_byte);
    printf("region id : %#x\n", table->region_id);
    printf("acl id : %#x\n", table->acl_id);
    printf("group id : %#x\n", table->group_id);
    for (int i=0; i < rule->key_desc_count; i++) {
        printf ("\tkey_list[%d] = %d  ", i, rule->key_desc_list_p[i].key_id);
        if (rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_DIP ||
            rule->key_desc_list_p[i].key_id == FLEX_ACL_KEY_SIP) {
            printf ("\tkey %s  ", inet_ntoa(rule->key_desc_list_p[i].key.dip.addr.ipv4));
            printf ("\tmask %s\n", inet_ntoa(rule->key_desc_list_p[i].mask.dip.addr.ipv4));
        }
        else {
            printf ("\tkey 0x%x  \tmask 0x%x\n",
                (uint32_t)rule->key_desc_list_p[i].key.src_port,(uint32_t)rule->key_desc_list_p[i].mask.vni_key);
        }
    }
  }
  if(rc) {
    SYSLOGF(LOG_ERR, "ERROR %d: [%s] Failed to insert rule at offset %d\n", rc, SX_STATUS_MSG(rc),*rule_offset);
    return -1;
  } else {
      printf("Inserted rule at offset %d\n", *rule_offset);
  }
  set_bitmap(table->valid_offsets, *rule_offset);
  return rc;
}

/*
 * Auto generate mapping of label port to logical port, used by the SDK APIs
 */
sx_status_t init_port_mapping(fx_handle_t handle) {
    // get all the ports
    handle->port_cnt = MAX_LOG_PORTS;
    sx_status_t rc = sx_api_port_swid_port_list_get(handle->sdk_handle,
            0,
            &handle->log_port_list[0],
            &handle->port_cnt);
    if (rc) {
        printf("Error sx_api_port_swid_port_list_get: %s\n",SX_STATUS_MSG(rc));
        return rc;
    }
    sx_port_attributes_t* port_attrs = (sx_port_attributes_t*)malloc(sizeof(sx_port_attributes_t)*handle->port_cnt);
    uint32_t pattr = handle->port_cnt;
    rc = sx_api_port_device_get(handle->sdk_handle, DEV_ID, 0, port_attrs, &pattr);
    if (rc) {
        printf("Error retrieving port mapping: %s\n",SX_STATUS_MSG(rc));
        free (port_attrs);
        return rc;
    }
    // There are 3 kinds of port IDs
    // 1. log_port   [0x10000..0x14000] - logical port, used in SDK APIs
    // 2. index      [0..31]            - similar to local port assigned by SDK, but internal to this app
    // 3. label_port [1..32]            - label port, as seen on the front panel
    // Assign label 0 to mean any port. Give it an index outside any physical port
    handle->label_port_list[0] = MAX_LOG_PORTS;
    handle->index_port_list[MAX_LOG_PORTS] = 0;
    handle->log_port_list[MAX_LOG_PORTS] = 0;
    for (unsigned int i = 0; i < handle->port_cnt; i++) {
        // Find the label of the port. This is the interface to the controller
        int label = 0;
        if (i < pattr) {
            label = port_attrs[i].port_mapping.module_port + 1;
            if (label <= MAX_LOG_PORTS) { // index zero based, label 1 based
                handle->label_port_list[label] = i;
                handle->index_port_list[i] = label;
                handle->port_mode[i] = port_attrs[i].port_mode;
            }
            else {
                printf("Unable to map Logical port %i : %#010x,  label: %i\n",i, handle->log_port_list[i], label);
            }
        }
        else {
            printf("Logical port %i : %#010x,  label: UNKNOWN \n",i, handle->log_port_list[i]);
        }
    }
    free(port_attrs);
    return rc;
}

sx_status_t fx_logical_port_get(fx_handle_t handle, uint32_t label_port, sx_port_log_id_t* log_port) {
    sx_status_t rc = SX_STATUS_SUCCESS;
    if (handle == NULL) {
        SYSLOGF(LOG_ERR, "fx_logical_port_get() %s\n","invalid handle parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    if (label_port > MAX_LOG_PORTS) {
        SYSLOGF(LOG_ERR, "fx_logical_port_get() %s\n","invalid label port parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    if (log_port == NULL) {
        SYSLOGF(LOG_ERR, "fx_logical_port_get() %s\n","invalid logical port parameter");
        return SX_STATUS_PARAM_ERROR;
    }
    *log_port = handle->log_port_list[handle->label_port_list[label_port]];
    return rc;
}



/*  Thes functions create/destroy a control pipeline.*/
sx_status_t fx_pipe_create(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
  return(
    (*fx_create_pipe_x_fn[pipe_type])(handle, if_list, if_list_cnt));
}


sx_status_t fx_pipe_destroy(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
    /* TODO - move , if_list, if_list_cnt to fx_handle */
  (void)if_list;
  (void)if_list_cnt;
  return(
    (*fx_delete_pipe_x_fn[pipe_type])(handle));
}


sx_status_t fx_pipe_rebind(
        fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        void *if_list,
        uint32_t if_list_cnt){
  return(
    (*fx_rebind_pipe_x_fn[pipe_type])(handle, if_list, if_list_cnt));
}


/* For external applications that create their own ACL tables, but then
 * want to bind in front of the ordered cascade of auto generated P4 tables
 */
sx_status_t fx_pipe_set_pre_acl_bind(fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        sx_acl_id_t *acl_list,
        uint32_t acl_list_cnt) {
    if (pipe_type >= FX_PIPE_TYPE_MIN && pipe_type < FX_PIPE_TYPE_MAX &&
            acl_list != 0 && acl_list_cnt != 0) {

        handle->pre_pipe_id_list[pipe_type] = acl_list;
        handle->pre_pipe_id_count[pipe_type] = acl_list_cnt;
        return SX_STATUS_SUCCESS;
    }
    else {
        return SX_STATUS_ERROR;
    }
}

/* For external applications that create their own ACL tables, but then
 * want to bind at the end of the ordered cascade of auto generated P4 tables
 */
sx_status_t fx_pipe_set_post_acl_bind(fx_handle_t handle,
        fx_pipe_type_t pipe_type,
        sx_acl_id_t *acl_list,
        uint32_t acl_list_cnt) {
    if (pipe_type >= FX_PIPE_TYPE_MIN && pipe_type < FX_PIPE_TYPE_MAX &&
            acl_list != 0 && acl_list_cnt != 0) {

        handle->post_pipe_id_list[pipe_type] = acl_list;
        handle->post_pipe_id_count[pipe_type] = acl_list_cnt;
        return SX_STATUS_SUCCESS;
    }
    else {
        return SX_STATUS_ERROR;
    }
}


/*  These functions add/re
move a table entry
use function mapping to implement static api */

sx_status_t fx_table_entry_add(fx_handle_t handle, const fx_table_id_t table_id, const fx_action_id_t action_id, fx_key_list_t keys, fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  // TODO action enum to id 
  return((*fx_table_x_entry_add_fn[table_index])(handle, action_id, keys, params, offset_ptr) );
}

sx_status_t fx_table_entry_remove(fx_handle_t handle, const fx_table_id_t table_id, sx_acl_rule_offset_t offset){
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  if (table->range_table==NULL){
    /* handle exact/ternery match tables */
    return(remove_table_entry( handle, table, offset));
  }
  else{
    /* handle range match tables */
    switch(table_id){
      default:
        printf("ERROR: fx_table_entry_remove table_id: %d, table_id missmatch.\n",table_id);
        return(SX_STATUS_PARAM_ERROR);
    }
  }
}

/* find the rule that matches the keys, if caller does not know the offset */
sx_status_t fx_table_entry_offset_find(fx_handle_t handle, const fx_table_id_t table_id, fx_key_list_t keys,
        sx_acl_rule_offset_t* offset) {
    int table_index;
    sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
    if (rc) return rc;
    struct acl_table *table = &handle->acl_tables[table_index];
    sx_acl_rule_offset_t offsets[table->table_size];
    uint32_t rules_count = 0;
    for (int i=0; i<table->table_size; i++) {
        if (get_bitmap(table->valid_offsets, i) != 0) {
            offsets[rules_count] = i;
            rules_count++;
        }
    }
    sx_flex_acl_flex_rule_t* rules = (sx_flex_acl_flex_rule_t*) malloc(rules_count*sizeof(sx_flex_acl_flex_rule_t));
    for (int i=0; i<rules_count; i++) {
        sx_lib_flex_acl_rule_init(table->key_handle, 10, &rules[i]);
    }
    if (table->range_table==NULL){
        rc = sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, &offsets[0], rules, &rules_count);
        if (rc) {
            SYSLOGF(LOG_ERR, "sx_api_acl_flex_rules_get() failed to find ACL rule: %i\n", rc);
        }
        else if (rules_count > 0) {
            rc = sx_api_acl_flex_rules_get(handle->sdk_handle, table->region_id, &offsets[0], rules, &rules_count);
            rc = SX_STATUS_ENTRY_NOT_FOUND;
            bool found = false;
            for (int i=0; i<rules_count; i++) {
                // missing rule keys indicate don't care for ternary/lpm rules
                // they are identified by type instead of an index
                if (rules[i].key_desc_count <= keys.len) {
                    if (rules[i].key_desc_list_p != NULL) {
                        for (int j=0; j<rules[i].key_desc_count; j++) {
                            SYSLOGF(LOG_WARNING, "Rule %i: key id %u\n",i, rules[i].key_desc_list_p[j].key_id);
                            const sx_acl_key_fields_t *key_fields = &rules[i].key_desc_list_p[j].key;
                            // fx_byte array has null values for ket index that mean don't care
                            int key_count = 0;
                            for (int y=0; y < keys.len; y++) {
                                if (keys.keys[y].key.data != NULL && key_count == j) {
                                    const fx_bytearray_t *key_data = &keys.keys[y].key;
                                    found = (0 == memcmp(&key_fields->buff, key_data->data, key_data->len));
                                    key_count++;
                                    break;
                                }
                            }
                        }
                        if (found) {
                            *offset = offsets[i];
                            rc = SX_STATUS_SUCCESS;
                            SYSLOGF(LOG_WARNING, "FOUND Rule %i: offset %i",i, *offset);
                            break;
                        }
                    }
                }
                else {
                    SYSLOGF(LOG_ERR, "Mismatch error in key count (%i > %i), table ID %i\n",
                            rules[i].key_desc_count, (int)keys.len, table_id);
                    for (int x=0; x < rules[i].key_desc_count; x++) {
                        if (rules[i].key_desc_list_p != NULL)
                            SYSLOGF(LOG_ERR,"\t Key ID %i, value %#010x\n", rules[i].key_desc_list_p[x].key_id, rules[i].key_desc_list_p[x].key.mpls_label_id_1);
                    }
                    for (int y=0; y < keys.len; y++) {
                        if (keys.keys[y].key.data != NULL)
                            SYSLOGF(LOG_ERR,"\t Key #%i, data %#010x\n", y, *((uint32_t*)keys.keys[y].key.data));
                    }
                    rc = SX_STATUS_PARAM_ERROR;
                }
            }
            if (!found) {
                SYSLOGF(LOG_ERR,"Failed to find modify key out of %i flex rules\n", rules_count);
            }
        }
    }
    else {
        /* TODO - handle range match tables */
        rc = SX_STATUS_PARAM_ERROR;
        SYSLOGF(LOG_ERR,"Modify range table not supported: %i\n", rc);
    }
    for (int i=0; i<rules_count; i++) {
        sx_lib_flex_acl_rule_deinit(&rules[i]);
    }
    free(rules);
    return rc;
}

sx_status_t fx_table_entry_default_set(fx_handle_t handle, const fx_table_id_t table_id, const fx_action_id_t action_id, fx_param_list_t params){
    int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) return rc;
  struct acl_table *table = &handle->acl_tables[table_index];
  return( (*fx_table_x_default_entry_set_fn[table_index])(handle, table,params,action_id));
}


void fx_table_entry_print_all(fx_handle_t handle, char *buffer, size_t len) {
    const int num_tables = 2;
    int c = snprintf(buffer, len, "Rules for %i tables\n", 2);
    for (int i = 0; i < num_tables; i++) {
        struct acl_table* table = &handle->acl_tables[i];
        c += snprintf(buffer+c, len, "[%i] rules for %s:\n", i, table->table_name);
        for (int i=0; i<table->table_size; i++) {
            if (get_bitmap(table->valid_offsets, i) == 1) {
                c += snprintf(buffer+c, len, "#%i ", i);
                for (int j=0; j < table->key_count; j++) {
                    c += snprintf(buffer+c,len, "%i, ", table->key_list[j]);
                }
                uint64_t bytes, packets = 0;
                fx_table_rule_counter_read(handle, table->table_id, i, &bytes, &packets);
                c += snprintf(buffer+c,len, "   bytes: %" PRIu64 " packets: %" PRIu64 "\n", bytes, packets);
            }
        }
    }
}

void fx_table_deinit_keys(fx_handle_t handle, fx_table_id_t table_id, fx_key_list_t keys[], size_t rule_cnt) {
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) {
      printf("Error getting table index from id %d [fx_table_init_keys]\n", table_id);
      return;
  }
 
  // TODO action enum to id 
  return((*fx_table_x_deinit_keys_fn[table_index])(keys, rule_cnt) );
}

void fx_table_init_keys(fx_handle_t handle, fx_table_id_t table_id, fx_key_list_t keys[], size_t rule_cnt) {
  int table_index;
  sx_status_t rc = get_table_index_from_id (handle, table_id, &table_index);
  if (rc) {
      printf("Error getting table index from id %d [fx_table_init_keys]\n", table_id);
      return;
  }
  // TODO action enum to id 
  return((*fx_table_x_init_keys_fn[table_index])(keys, rule_cnt) );
}

sx_status_t check_action_params(fx_param_list_t params, fx_action_id_t action_id) {
  /* CHECK ACTION PARAMS */
	switch(action_id){
		case CONTROL_IN_RIF_SET_METADATA_ID:
		{
          if (params.len != 1) {
            printf("ERROR: ""Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.set_metadata\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
		}
		case CONTROL_IN_RIF_TO_CPU_ID:
		{
          if (params.len != 1) {
            printf("ERROR: ""Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.to_cpu\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
		}
		case CONTROL_IN_RIF_TO_NEXTHOP_ID:
		{
          if (params.len != 1) {
            printf("ERROR: ""Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.to_nexthop\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
		}
		case CONTROL_IN_RIF_TO_LOCAL_ID:
		{
          if (params.len != 1) {
            printf("ERROR: ""Got invalid parameters list of length %zu while expecting 1 in action control_in_rif.to_local\n", params.len);
            return SX_STATUS_PARAM_ERROR;
          }
		}
		default: {}
    }
  /* CHECK ACTION PARAMS */
   return SX_STATUS_SUCCESS;
}

void reverse_bytes(uint8_t head[], size_t len) {
    uint8_t temp;
    for (int i=0; i<len/2; i++) {
        temp = head[i];
        head[i] = head[len-i-1];
        head[len-i-1] = temp;
    }
}

/*
 * Build the ACL rule action list using the parameter data provided. The P4
 * Compiler must verify that the action is valid for a given pipeline stage,
 * as no runtime check is performed (e.g. using an in_rif only action at the in_port stage).
*/
void set_action_list(fx_handle_t handle, int action_id, fx_param_list_t params, struct acl_table *table, sx_acl_rule_offset_t* offset_ptr , sx_flex_acl_flex_rule_t* rule ) {
	if (rule->action_list_p == NULL) { syslog(LOG_ERR, "Flex action uninitialized (sx_lib_flex_acl_rule_init)"); return;}
	switch(action_id) { // 6 unique actions out of 7 action invocations
		case CONTROL_IN_RIF_DROP_ID:
		{
			/* mlnx_drop() */
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_FORWARD,
				.fields.action_forward.action = (sx_flex_acl_forward_action_t) SX_ACL_TRAP_FORWARD_ACTION_TYPE_DISCARD,
			};
			break;
		};
		case CONTROL_IN_RIF_SET_METADATA_ID:
		{
			/* set_inrif1_reg32(in_rif_metadata, 0xffffffff) */
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_SET_DST_MAC,
			/*	.fields.action_set_dst_mac.mac = *(uint8_t*)(params.params[0].data), */
			};
			if (4 > params.params[0].len) { syslog(LOG_ERR,"ERROR in action parameter size"); }
			uint8_t* mac = (uint8_t*)(&rule->action_list_p[0].fields.action_set_dst_mac.mac);
			memcpy(&mac[0], params.params[0].data, 4);
			/* hit_counter() */
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case CONTROL_IN_RIF_TO_CPU_ID:
		{
			/* trap(0, trap_id) */
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_TRAP,
				.fields.action_trap.action = (sx_flex_acl_trap_action_t) 0,
			/*	.fields.action_trap.trap_id = *(sx_trap_id_t*)(params.params[0].data), */
			};
			memcpy(&rule->action_list_p[0].fields.action_trap.trap_id, params.params[0].data, params.params[0].len);
			break;
		};
		case CONTROL_IN_RIF_TO_NEXTHOP_ID:
		{
			/* set_remote_uc_route(next_hop) */
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_UC_ROUTE,
			/*	.fields.action_uc_route.uc_route_param.ecmp_id = *(sx_ecmp_id_t*)(params.params[0].data), */
				.fields.action_uc_route.uc_route_type = (sx_uc_route_type_e) SX_UC_ROUTE_TYPE_NEXT_HOP,
			};
			memcpy(&rule->action_list_p[0].fields.action_uc_route.uc_route_param.ecmp_id, params.params[0].data, params.params[0].len);
			/* hit_counter() */
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case NOACTION_ID:
		{
			break;
		};
		case CONTROL_IN_RIF_TO_LOCAL_ID:
		{
			/* set_local_uc_route(router_interface) */
			rule->action_list_p[0] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_UC_ROUTE,
			/*	.fields.action_uc_route.uc_route_param.local_egress_rif = *(sx_router_interface_t*)(params.params[0].data), */
				.fields.action_uc_route.uc_route_type = (sx_uc_route_type_e) SX_UC_ROUTE_TYPE_LOCAL,
			};
			memcpy(&rule->action_list_p[0].fields.action_uc_route.uc_route_param.local_egress_rif, params.params[0].data, params.params[0].len);
			/* hit_counter() */
			rule->action_list_p[1] = (sx_flex_acl_flex_action_t){
				.type =  SX_FLEX_ACL_ACTION_COUNTER,
				.fields.action_counter.counter_id = (sx_flex_acl_forward_action_t) table->rule_counters[*offset_ptr],
			};
			break;
		};
		case FX_ACTION_INVALID_ID:
		default:
			syslog(LOG_ERR,"ERROR: requested action is not in the action list");
	}
	return;
}
// --------------- control_in_rif_table_bitmap_classification ------------
/************** per table APIs **************/
void fill_custom_bytes_control_in_rif_table_bitmap_classification(struct fx_custom_params *custom) {
  if (custom->is_cb) {
      custom->attr.extraction_points_count = 1;
      custom->attr.extraction_point.extraction_group_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_GROUP_L2;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.extraction_point_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_POINT_TYPE_L2_NONE;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.offset= custom->cb_offset;
  }
}

sx_status_t create_control_in_rif_table_bitmap_classification(fx_handle_t handle, sx_acl_id_t* pipe_id_list, int pipe_ind  ) {
  const uint32_t size = 32;
  const uint32_t key_count = 1;
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  table->table_id = CONTROL_IN_RIF_TABLE_BITMAP_CLASSIFICATION_ID;
  table->default_entry_offset= 31;
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_classification(&custom);
  table->table_size = size;
  table->key_count = key_count;
  printf("create_control_in_rif_table_bitmap_classification. size=%d keys=%d\n", table->table_size, table->key_count);
  table->key_list = (sx_acl_key_t*) malloc(sizeof(sx_acl_key_t) * table->key_count);
  if (table->key_list == NULL){
    printf("ERROR: in create_control_in_rif_table_bitmap_classification No memory to create key list\n");
    return SX_STATUS_NO_MEMORY;
  } 
  table->pipe_line = SX_ACL_DIRECTION_RIF_INGRESS; // replaced with pipeline (hook location)
  strncpy(table->table_name, "control_in_rif_table_bitmap_classification", MAX_TABLE_NAME_LEN);

  /* Key assignment includes custom bytes - for CB SDK should allow P4C to provide a hint */
  /* KEY ASSIGN START */
  table->key_list[0] = FLEX_ACL_KEY_IRIF;
  /* KEY ASSIGN END */

  sx_status_t rc =  create_p4_table(handle, table, &custom);
  if (rc) {
      printf("Error: create_control_in_rif_table_bitmap_classification, table #%d with acl ID %d\n", table_index, table->acl_id);
     return rc;
  } else {
      printf("create_control_in_rif_table_bitmap_classification, table #%d with acl ID %d\n", table_index, table->acl_id);
  }
	table->range_table = NULL;  
  pipe_id_list[pipe_ind] = table->acl_id;
  return SX_STATUS_SUCCESS;
}

sx_status_t delete_control_in_rif_table_bitmap_classification(fx_handle_t handle) {
  printf("delete_control_in_rif_table_bitmap_classification. \n");
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_classification(&custom);
  sx_status_t rc = delete_p4_table(handle, table, &custom);
  free(table->key_list);
  table->key_list = 0;
  if (rc) {
    return rc;
  }
  return SX_STATUS_SUCCESS;
}



sx_status_t fx_control_in_rif_table_bitmap_classification_default_entry_set(fx_handle_t handle, struct acl_table *table, fx_param_list_t params,int action_id){
  sx_acl_rule_offset_t offset  = table->default_entry_offset;
  sx_acl_rule_offset_t *offset_ptr = &offset;
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  sx_flex_acl_flex_rule_t default_rule;
  sx_flex_acl_flex_rule_t *rule = &default_rule;
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  printf("insert rule to control_in_rif_table_bitmap_classification index %d\n",offset);
  /* __TABLE_DEFAULT_ENTRY_KEYS_||_ */
  rule->key_desc_list_p = NULL;
  rule->key_desc_count = 0;
  // init action
  set_action_list(handle, action_id, params, table, offset_ptr, rule );
  rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}


sx_status_t check_input_lengths_control_in_rif_table_bitmap_classification(fx_key_list_t keys, fx_param_list_t params, fx_action_id_t action_id) {
  /* TABLE ENTRY CHECK KEYS START */
  if (keys.len != 1) {
    printf("ERROR: ""Got invalid keys length %zu while expecting 1, in table control_in_rif.table_bitmap_classification\n", keys.len);
    return SX_STATUS_PARAM_ERROR;
  }

  /* Key #0: FLEX_ACL_KEY_IRIF */
  if (keys.keys[0].key.data != NULL) {
    if (keys.keys[0].key.len != sizeof(sx_router_interface_t)) {
      printf("ERROR: ""Got key (0) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_classification\n", keys.keys[0].key.len, sizeof(sx_router_interface_t));
      return SX_STATUS_PARAM_ERROR;
    }
  }

  /* TABLE ENTRY CHECK KEYS END */
    return check_action_params(params, action_id);
}

void fx_init_key_list_control_in_rif_table_bitmap_classification(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (int i=0; i < rule_cnt; i++) {
  /* INIT RULE START */
      key_lists[i].len = 1;
      key_lists[i].keys = (fx_key_t*) malloc(1 * sizeof(fx_key_t));
      key_lists[i].keys[0].key.data = NULL;
      key_lists[i].keys[0].mask.data = NULL;
  /* INIT RULE END */
    }
}

void fx_deinit_key_list_control_in_rif_table_bitmap_classification(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (int i=0; i < rule_cnt; i++) {
        free(key_lists[i].keys);
    }
}

sx_status_t add_table_entry_control_in_rif_table_bitmap_classification_internal(fx_handle_t handle,struct acl_table *table, sx_flex_acl_flex_rule_t *rule, fx_key_list_t keys,fx_param_list_t params, fx_action_id_t action_id, sx_acl_rule_offset_t* offset_ptr)
{
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  printf("insert rule to control_in_rif_table_bitmap_classification index %d\n",*offset_ptr);
  /* TABLE ENTRY KEYS START */
  /* sx_lib_flex_acl_rule_init allocated 1 * sizeof(sx_flex_acl_key_desc_t) bytes */
  int curr_key=0;
  if (keys.keys[0].key.data != NULL) { /* Key #0: irif */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[0],
      };
      memcpy(&rule->key_desc_list_p[curr_key].key.irif, keys.keys[0].key.data, keys.keys[0].key.len);
      rule->key_desc_list_p[curr_key].mask.irif = 1; // exact match
      ++curr_key;
  }
  rule->key_desc_count=curr_key; /* key #1 */
  /* TABLE ENTRY KEYS END */
  // init action
  set_action_list(handle, action_id, params, table, offset_ptr, rule );
  rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}

/* API for the CLI app - This can be made to be more user friendly */
sx_status_t add_table_entry_control_in_rif_table_bitmap_classification(fx_handle_t handle, fx_action_id_t action_id, fx_key_list_t keys,fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  /* EXACT OFFSET START */
  get_exact_offset_internal(table, offset_ptr);
  /* EXACT OFFSET END */
  sx_status_t           rc = SX_STATUS_SUCCESS;
  sx_flex_acl_flex_rule_t  rule;
  rc = check_input_lengths_control_in_rif_table_bitmap_classification(keys, params, action_id);
  if (rc) return rc;
  /* Convert keys and mask from user friendly format to machine friendly here */
  rc = add_table_entry_control_in_rif_table_bitmap_classification_internal(handle,table,&rule,keys,params,action_id, offset_ptr);
  return rc;
}

sx_status_t remove_table_entry_control_in_rif_table_bitmap_classification(fx_handle_t handle, sx_acl_rule_offset_t offset){
  const int table_index = 0; // 0 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  printf("remove rule from control_in_rif_table_bitmap_classification, offset =  %d\n",offset);
  return remove_table_entry(handle,table, offset);
}

// --------end of control_in_rif_table_bitmap_classification----------------

// --------------- control_in_rif_table_bitmap_router ------------
/************** per table APIs **************/
void fill_custom_bytes_control_in_rif_table_bitmap_router(struct fx_custom_params *custom) {
  if (custom->is_cb) {
      custom->attr.extraction_points_count = 1;
      custom->attr.extraction_point.extraction_group_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_GROUP_L2;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.extraction_point_type=SX_ACL_CUSTOM_BYTES_EXTRACTION_POINT_TYPE_L2_NONE;
      custom->attr.extraction_point.params.extraction_l2_group.extraction_l2.offset= custom->cb_offset;
  }
}

sx_status_t create_control_in_rif_table_bitmap_router(fx_handle_t handle, sx_acl_id_t* pipe_id_list, int pipe_ind  ) {
  const uint32_t size = 512;
  const uint32_t key_count = 2;
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  table->table_id = CONTROL_IN_RIF_TABLE_BITMAP_ROUTER_ID;
  table->default_entry_offset= 255;
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_router(&custom);
  table->table_size = size;
  table->key_count = key_count;
  printf("create_control_in_rif_table_bitmap_router. size=%d keys=%d\n", table->table_size, table->key_count);
  table->key_list = (sx_acl_key_t*) malloc(sizeof(sx_acl_key_t) * table->key_count);
  if (table->key_list == NULL){
    printf("ERROR: in create_control_in_rif_table_bitmap_router No memory to create key list\n");
    return SX_STATUS_NO_MEMORY;
  } 
  table->pipe_line = SX_ACL_DIRECTION_RIF_INGRESS; // replaced with pipeline (hook location)
  strncpy(table->table_name, "control_in_rif_table_bitmap_router", MAX_TABLE_NAME_LEN);

  /* Key assignment includes custom bytes - for CB SDK should allow P4C to provide a hint */
  /* KEY ASSIGN START */
  table->key_list[0] = FLEX_ACL_KEY_DMAC;
  table->key_list[1] = FLEX_ACL_KEY_DIP;
  /* KEY ASSIGN END */

  sx_status_t rc =  create_p4_table(handle, table, &custom);
  if (rc) {
      printf("Error: create_control_in_rif_table_bitmap_router, table #%d with acl ID %d\n", table_index, table->acl_id);
     return rc;
  } else {
      printf("create_control_in_rif_table_bitmap_router, table #%d with acl ID %d\n", table_index, table->acl_id);
  }
	table->range_table = NULL;  
  pipe_id_list[pipe_ind] = table->acl_id;
  return SX_STATUS_SUCCESS;
}

sx_status_t delete_control_in_rif_table_bitmap_router(fx_handle_t handle) {
  printf("delete_control_in_rif_table_bitmap_router. \n");
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  struct fx_custom_params custom = {false, 0, 0, 0, 0};
  fill_custom_bytes_control_in_rif_table_bitmap_router(&custom);
  sx_status_t rc = delete_p4_table(handle, table, &custom);
  free(table->key_list);
  table->key_list = 0;
  if (rc) {
    return rc;
  }
  return SX_STATUS_SUCCESS;
}



sx_status_t fx_control_in_rif_table_bitmap_router_default_entry_set(fx_handle_t handle, struct acl_table *table, fx_param_list_t params,int action_id){
  sx_acl_rule_offset_t offset  = table->default_entry_offset;
  sx_acl_rule_offset_t *offset_ptr = &offset;
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  sx_flex_acl_flex_rule_t default_rule;
  sx_flex_acl_flex_rule_t *rule = &default_rule;
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  printf("insert rule to control_in_rif_table_bitmap_router index %d\n",offset);
  /* __TABLE_DEFAULT_ENTRY_KEYS_||_ */
  rule->key_desc_list_p = NULL;
  rule->key_desc_count = 0;
  // init action
  set_action_list(handle, action_id, params, table, offset_ptr, rule );
  rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}


sx_status_t check_input_lengths_control_in_rif_table_bitmap_router(fx_key_list_t keys, fx_param_list_t params, fx_action_id_t action_id) {
  /* TABLE ENTRY CHECK KEYS START */
  if (keys.len != 2) {
    printf("ERROR: ""Got invalid keys length %zu while expecting 2, in table control_in_rif.table_bitmap_router\n", keys.len);
    return SX_STATUS_PARAM_ERROR;
  }

  /* Key #0: DERIVED_IN_RIF1_REG32 */
  if (keys.keys[0].key.data != NULL) {
    if (keys.keys[0].key.len != 4) {
      printf("ERROR: ""Got key (0) of length %zu while expecting 4, in table control_in_rif.table_bitmap_router\n", keys.keys[0].key.len);
      return SX_STATUS_PARAM_ERROR;
    }
    if (keys.keys[0].mask.data != NULL) {
      if (keys.keys[0].mask.len != 4) {
        printf("ERROR: ""Got mask (0) of length %zu while expecting 4, in table control_in_rif.table_bitmap_router\n", keys.keys[0].mask.len);
        return SX_STATUS_PARAM_ERROR;
      }
    }
  }

  /* Key #1: FLEX_ACL_KEY_DIP */
  if (keys.keys[1].key.data != NULL) {
    if (keys.keys[1].key.len != sizeof(in_addr_t)) {
      printf("ERROR: ""Got key (1) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_router\n", keys.keys[1].key.len, sizeof(in_addr_t));
      return SX_STATUS_PARAM_ERROR;
    }
    if (keys.keys[1].mask.data != NULL) {
      if (keys.keys[1].mask.len != sizeof(in_addr_t)) {
        printf("ERROR: ""Got mask (1) of length %zu while expecting %lu, in table control_in_rif.table_bitmap_router\n", keys.keys[1].mask.len, sizeof(in_addr_t));
        return SX_STATUS_PARAM_ERROR;
      }
    }
  }

  /* TABLE ENTRY CHECK KEYS END */
    return check_action_params(params, action_id);
}

void fx_init_key_list_control_in_rif_table_bitmap_router(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (int i=0; i < rule_cnt; i++) {
  /* INIT RULE START */
      key_lists[i].len = 2;
      key_lists[i].keys = (fx_key_t*) malloc(2 * sizeof(fx_key_t));
      key_lists[i].keys[0].key.data = NULL;
      key_lists[i].keys[0].mask.data = NULL;
      key_lists[i].keys[1].key.data = NULL;
      key_lists[i].keys[1].mask.data = NULL;
  /* INIT RULE END */
    }
}

void fx_deinit_key_list_control_in_rif_table_bitmap_router(fx_key_list_t key_lists[], size_t rule_cnt) {
    for (int i=0; i < rule_cnt; i++) {
        free(key_lists[i].keys);
    }
}

sx_status_t add_table_entry_control_in_rif_table_bitmap_router_internal(fx_handle_t handle,struct acl_table *table, sx_flex_acl_flex_rule_t *rule, fx_key_list_t keys,fx_param_list_t params, fx_action_id_t action_id, sx_acl_rule_offset_t* offset_ptr)
{
  int sdk_action_count;
  sx_status_t rc = get_sdk_action_num_from_id(action_id,&sdk_action_count);
  if (rc) {return rc;}
  rc = sx_lib_flex_acl_rule_init(table->key_handle,sdk_action_count,rule);
  if (rc) {return rc;}
  rule->valid=1;
  printf("insert rule to control_in_rif_table_bitmap_router index %d\n",*offset_ptr);
  /* TABLE ENTRY KEYS START */
  /* sx_lib_flex_acl_rule_init allocated 2 * sizeof(sx_flex_acl_key_desc_t) bytes */
  int curr_key=0;
  if (keys.keys[0].key.data != NULL) { /* Key #0: dmac.ether_addr_octet */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[0],
      };
      u_int8_t* tmp_key = (u_int8_t*)(&rule->key_desc_list_p[curr_key].key.dmac.ether_addr_octet);
      memcpy(&tmp_key[0], keys.keys[0].key.data, keys.keys[0].key.len);
      memcpy(&rule->key_desc_list_p[curr_key].mask.dmac.ether_addr_octet, keys.keys[0].mask.data, keys.keys[0].mask.len);
      ++curr_key;
  }
  if (keys.keys[1].key.data != NULL) { /* Key #1: dip.addr.ipv4.s_addr */
     rule->key_desc_list_p[curr_key]=(sx_flex_acl_key_desc_t){
         .key_id =table->key_list[1],
        .key.dip.version =SX_IP_VERSION_IPV4, 
        .mask.dip.version =SX_IP_VERSION_IPV4, 
      };
      memcpy(&rule->key_desc_list_p[curr_key].key.dip.addr.ipv4.s_addr, keys.keys[1].key.data, keys.keys[1].key.len);
      memcpy(&rule->key_desc_list_p[curr_key].mask.dip.addr.ipv4.s_addr, keys.keys[1].mask.data, keys.keys[1].mask.len);
      ++curr_key;
  }
  rule->key_desc_count=curr_key; /* key #2 */
  /* TABLE ENTRY KEYS END */
  // init action
  set_action_list(handle, action_id, params, table, offset_ptr, rule );
  rc = add_acl_rule_internal(handle, rule, offset_ptr, table);
  sx_lib_flex_acl_rule_deinit(rule);
  return rc;
}

/* API for the CLI app - This can be made to be more user friendly */
sx_status_t add_table_entry_control_in_rif_table_bitmap_router(fx_handle_t handle, fx_action_id_t action_id, fx_key_list_t keys,fx_param_list_t params, sx_acl_rule_offset_t* offset_ptr){
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  /* EXACT OFFSET START */
  if(*offset_ptr == table->default_entry_offset){
    printf("Error: add table entry: rule offset same as default entry offset: %u, skipping rule.\n",(unsigned int)*offset_ptr);
    return SX_STATUS_PARAM_ERROR;  }
  /* EXACT OFFSET END */
  sx_status_t           rc = SX_STATUS_SUCCESS;
  sx_flex_acl_flex_rule_t  rule;
  rc = check_input_lengths_control_in_rif_table_bitmap_router(keys, params, action_id);
  if (rc) return rc;
  /* Convert keys and mask from user friendly format to machine friendly here */
  rc = add_table_entry_control_in_rif_table_bitmap_router_internal(handle,table,&rule,keys,params,action_id, offset_ptr);
  return rc;
}

sx_status_t remove_table_entry_control_in_rif_table_bitmap_router(fx_handle_t handle, sx_acl_rule_offset_t offset){
  const int table_index = 1; // 1 is replaced by macro
  struct acl_table *table = &handle->acl_tables[table_index];
  printf("remove rule from control_in_rif_table_bitmap_router, offset =  %d\n",offset);
  return remove_table_entry(handle,table, offset);
}

// --------end of control_in_rif_table_bitmap_router----------------

// -------------PIPE CODE CONTROL_IN_PORT -----------------------------------
// pipe: control_in_port
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_INGRESS
// type rif/port : port
// auto tables iteration over:
// if_list type: pptype
// fx pipe enum: FX_CONTROL_IN_PORT

static port_handle_type *control_in_port_bind_list = NULL;
static uint32_t control_in_port_bind_list_cnt = 0;

sx_status_t create_pipe_control_in_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_IN_PORT] + CONTROL_IN_PORT_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_IN_PORT];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (int i=0; i < handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_IN_PORT][i];
	for (int i=0; i < CONTROL_IN_PORT_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]] = handle->control_in_port_id_list[i];
	for (int i=0; i < handle->post_pipe_id_count[FX_CONTROL_IN_PORT]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_PORT]+CONTROL_IN_PORT_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_IN_PORT][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_INGRESS, acl_id_list, acl_id_count , &handle->control_in_port_group_id);
	if(rc) {
	    syslog(LOG_ERR,"ERROR in creating control_in_port group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	printf("Pipe control_in_port was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = port_bind(handle,handle->control_in_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	control_in_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_in_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_in_port_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_in_port(fx_handle_t handle){
    if (control_in_port_bind_list == 0 || control_in_port_bind_list_cnt ==0) return 0;
	sx_status_t rc1 = port_bind(handle, handle->control_in_port_group_id,(boolean_t) false, control_in_port_bind_list,control_in_port_bind_list_cnt);
	free(control_in_port_bind_list);
	control_in_port_bind_list = NULL;
	control_in_port_bind_list_cnt = 0;
	if (rc1) {
        syslog(LOG_ERR,"ERROR in unbinding control_in_port group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_INGRESS , &handle->control_in_port_group_id);
	if (rc2) {
        syslog(LOG_ERR,"ERROR in deleting control_in_port group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	for (int i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	printf("Pipe control_in_port was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_in_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = port_bind(handle, handle->control_in_port_group_id,(boolean_t) false, control_in_port_bind_list,control_in_port_bind_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in unbinding control_in_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_in_port_bind_list);
	control_in_port_bind_list = NULL;
	control_in_port_bind_list_cnt = 0;
	rc = port_bind(handle,handle->control_in_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in binding control_in_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_in_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_in_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_in_port_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_IN_RIF -----------------------------------
// pipe: control_in_rif
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_RIF_INGRESS
// type rif/port : rif
// auto tables iteration over:
// table name: control_in_rif_table_bitmap_classification ,  index : 0
// table name: control_in_rif_table_bitmap_router ,  index : 1
// if_list type: pptype
// fx pipe enum: FX_CONTROL_IN_RIF

static rif_handle_type *control_in_rif_bind_list = NULL;
static uint32_t control_in_rif_bind_list_cnt = 0;

sx_status_t create_pipe_control_in_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	if (create_control_in_rif_table_bitmap_classification(handle, handle->control_in_rif_id_list,0)){syslog(LOG_ERR,"ERROR in creating control_in_rif, pipe table: control_in_rif_table_bitmap_classification\n"); return SX_STATUS_ERROR;}
	if (create_control_in_rif_table_bitmap_router(handle, handle->control_in_rif_id_list,1)){syslog(LOG_ERR,"ERROR in creating control_in_rif, pipe table: control_in_rif_table_bitmap_router\n"); return SX_STATUS_ERROR;}
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_IN_RIF] + CONTROL_IN_RIF_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_IN_RIF];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (int i=0; i < handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_IN_RIF][i];
	for (int i=0; i < CONTROL_IN_RIF_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]] = handle->control_in_rif_id_list[i];
	for (int i=0; i < handle->post_pipe_id_count[FX_CONTROL_IN_RIF]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_IN_RIF]+CONTROL_IN_RIF_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_IN_RIF][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_RIF_INGRESS, acl_id_list, acl_id_count , &handle->control_in_rif_group_id);
	if(rc) {
	    syslog(LOG_ERR,"ERROR in creating control_in_rif group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	printf("Pipe control_in_rif was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = rif_bind(handle,handle->control_in_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	control_in_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * if_list_cnt);
	memcpy(control_in_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_in_rif_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_in_rif(fx_handle_t handle){
    if (control_in_rif_bind_list == 0 || control_in_rif_bind_list_cnt ==0) return 0;
	sx_status_t rc1 = rif_bind(handle, handle->control_in_rif_group_id,(boolean_t) false, control_in_rif_bind_list,control_in_rif_bind_list_cnt);
	free(control_in_rif_bind_list);
	control_in_rif_bind_list = NULL;
	control_in_rif_bind_list_cnt = 0;
	if (rc1) {
        syslog(LOG_ERR,"ERROR in unbinding control_in_rif group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_RIF_INGRESS , &handle->control_in_rif_group_id);
	if (rc2) {
        syslog(LOG_ERR,"ERROR in deleting control_in_rif group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	if (delete_control_in_rif_table_bitmap_classification(handle)) {syslog(LOG_ERR,"ERROR in deleting control_in_rif, pipe table num: 0\n"); rc = SX_STATUS_ERROR;}
	if (delete_control_in_rif_table_bitmap_router(handle)) {syslog(LOG_ERR,"ERROR in deleting control_in_rif, pipe table num: 1\n"); rc = SX_STATUS_ERROR;}
	for (int i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	printf("Pipe control_in_rif was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_in_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
        fx_table_rule_counters_print_all(handle, CONTROL_IN_RIF_TABLE_BITMAP_CLASSIFICATION_ID);
	sx_status_t rc = rif_bind(handle, handle->control_in_rif_group_id,(boolean_t) false, control_in_rif_bind_list,control_in_rif_bind_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in unbinding control_in_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_in_rif_bind_list);
	control_in_rif_bind_list = NULL;
	control_in_rif_bind_list_cnt = 0;
	rc = rif_bind(handle,handle->control_in_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in binding control_in_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_in_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * if_list_cnt);
	memcpy(control_in_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_in_rif_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_OUT_RIF -----------------------------------
// pipe: control_out_rif
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_RIF_EGRESS
// type rif/port : rif
// auto tables iteration over:
// if_list type: pptype
// fx pipe enum: FX_CONTROL_OUT_RIF

static rif_handle_type *control_out_rif_bind_list = NULL;
static uint32_t control_out_rif_bind_list_cnt = 0;

sx_status_t create_pipe_control_out_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF] + CONTROL_OUT_RIF_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_OUT_RIF];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (int i=0; i < handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_OUT_RIF][i];
	for (int i=0; i < CONTROL_OUT_RIF_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]] = handle->control_out_rif_id_list[i];
	for (int i=0; i < handle->post_pipe_id_count[FX_CONTROL_OUT_RIF]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_RIF]+CONTROL_OUT_RIF_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_OUT_RIF][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_RIF_EGRESS, acl_id_list, acl_id_count , &handle->control_out_rif_group_id);
	if(rc) {
	    syslog(LOG_ERR,"ERROR in creating control_out_rif group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	printf("Pipe control_out_rif was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = rif_bind(handle,handle->control_out_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	control_out_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * if_list_cnt);
	memcpy(control_out_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_out_rif_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_out_rif(fx_handle_t handle){
    if (control_out_rif_bind_list == 0 || control_out_rif_bind_list_cnt ==0) return 0;
	sx_status_t rc1 = rif_bind(handle, handle->control_out_rif_group_id,(boolean_t) false, control_out_rif_bind_list,control_out_rif_bind_list_cnt);
	free(control_out_rif_bind_list);
	control_out_rif_bind_list = NULL;
	control_out_rif_bind_list_cnt = 0;
	if (rc1) {
        syslog(LOG_ERR,"ERROR in unbinding control_out_rif group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_RIF_EGRESS , &handle->control_out_rif_group_id);
	if (rc2) {
        syslog(LOG_ERR,"ERROR in deleting control_out_rif group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	for (int i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	printf("Pipe control_out_rif was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_out_rif(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = rif_bind(handle, handle->control_out_rif_group_id,(boolean_t) false, control_out_rif_bind_list,control_out_rif_bind_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in unbinding control_out_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_out_rif_bind_list);
	control_out_rif_bind_list = NULL;
	control_out_rif_bind_list_cnt = 0;
	rc = rif_bind(handle,handle->control_out_rif_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in binding control_out_rif group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_out_rif_bind_list = (rif_handle_type *)malloc(sizeof(rif_handle_type) * if_list_cnt);
	memcpy(control_out_rif_bind_list, if_list, sizeof(rif_handle_type) * if_list_cnt);
	control_out_rif_bind_list_cnt = if_list_cnt;

	return rc;
}

// -------------PIPE CODE CONTROL_OUT_PORT -----------------------------------
// pipe: control_out_port
// pipe indx: Pindx
// pipe direction : SX_ACL_DIRECTION_EGRESS
// type rif/port : port
// auto tables iteration over:
// if_list type: pptype
// fx pipe enum: FX_CONTROL_OUT_PORT

static port_handle_type *control_out_port_bind_list = NULL;
static uint32_t control_out_port_bind_list_cnt = 0;

sx_status_t create_pipe_control_out_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
    if (if_list == 0 || if_list_cnt ==0) return 0;
	//  compiler replaces below with N table creates
	uint32_t acl_id_count = handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT] + CONTROL_OUT_PORT_TABLE_NUM + handle->post_pipe_id_count[FX_CONTROL_OUT_PORT];
	sx_acl_id_t* acl_id_list = (sx_acl_id_t*)malloc(sizeof(sx_acl_id_t) * acl_id_count);
	for (int i=0; i < handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]; i++) acl_id_list[i] = handle->pre_pipe_id_list[FX_CONTROL_OUT_PORT][i];
	for (int i=0; i < CONTROL_OUT_PORT_TABLE_NUM; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]] = handle->control_out_port_id_list[i];
	for (int i=0; i < handle->post_pipe_id_count[FX_CONTROL_OUT_PORT]; i++) acl_id_list[i+handle->pre_pipe_id_count[FX_CONTROL_OUT_PORT]+CONTROL_OUT_PORT_TABLE_NUM] = handle->post_pipe_id_list[FX_CONTROL_OUT_PORT][i];
	sx_status_t rc;
	rc = assign_tables_to_group(handle, SX_ACL_DIRECTION_EGRESS, acl_id_list, acl_id_count , &handle->control_out_port_group_id);
	if(rc) {
	    syslog(LOG_ERR,"ERROR in creating control_out_port group: %s\n", SX_STATUS_MSG(rc));
	    free(acl_id_list);
	    return rc;
	}
	printf("Pipe control_out_port was created with %i tables on %i interfaces: ", acl_id_count, if_list_cnt);
	// Binding - port
	rc = port_bind(handle,handle->control_out_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	control_out_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_out_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_out_port_bind_list_cnt = if_list_cnt;
	free(acl_id_list);
	return rc;
}


sx_status_t delete_pipe_control_out_port(fx_handle_t handle){
    if (control_out_port_bind_list == 0 || control_out_port_bind_list_cnt ==0) return 0;
	sx_status_t rc1 = port_bind(handle, handle->control_out_port_group_id,(boolean_t) false, control_out_port_bind_list,control_out_port_bind_list_cnt);
	free(control_out_port_bind_list);
	control_out_port_bind_list = NULL;
	control_out_port_bind_list_cnt = 0;
	if (rc1) {
        syslog(LOG_ERR,"ERROR in unbinding control_out_port group: %s\n", SX_STATUS_MSG(rc1));
	}
	sx_status_t rc2 = delete_acl_group(handle, SX_ACL_DIRECTION_EGRESS , &handle->control_out_port_group_id);
	if (rc2) {
        syslog(LOG_ERR,"ERROR in deleting control_out_port group: %s\n", SX_STATUS_MSG(rc2));
	}
	//  compiler replaces below with N table deletes
	sx_status_t rc = SX_STATUS_SUCCESS;
	for (int i = FX_PIPE_TYPE_MIN; i < FX_PIPE_TYPE_MAX; i++) {
	    handle->pre_pipe_id_list[i] = 0;
	    handle->pre_pipe_id_count[i] = 0;
	}
	printf("Pipe control_out_port was deleted\n");
	return rc1 ? rc1 : (rc2 ? rc2 : rc);
}

sx_status_t rebind_pipe_control_out_port(fx_handle_t handle, void *if_list,uint32_t if_list_cnt){
	if (if_list == 0 || if_list_cnt ==0) return 0;
	sx_status_t rc = port_bind(handle, handle->control_out_port_group_id,(boolean_t) false, control_out_port_bind_list,control_out_port_bind_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in unbinding control_out_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	free(control_out_port_bind_list);
	control_out_port_bind_list = NULL;
	control_out_port_bind_list_cnt = 0;
	rc = port_bind(handle,handle->control_out_port_group_id,(boolean_t) true, if_list,if_list_cnt);
	if (rc) {
		syslog(LOG_ERR,"ERROR in binding control_out_port group: %s\n", SX_STATUS_MSG(rc));
		return rc;
	}
	control_out_port_bind_list = (port_handle_type *)malloc(sizeof(port_handle_type) * if_list_cnt);
	memcpy(control_out_port_bind_list, if_list, sizeof(port_handle_type) * if_list_cnt);
	control_out_port_bind_list_cnt = if_list_cnt;

	return rc;
}
